/****************************************************************************************
|  Description: Newlib system calls remapping source file
|    File Name: syscalls.c
|
|----------------------------------------------------------------------------------------
|                          C O P Y R I G H T
|----------------------------------------------------------------------------------------
|   Copyright (c) 2011  by Feaser    http://www.feaser.com    All rights reserved
|
|----------------------------------------------------------------------------------------
|                            L I C E N S E
|----------------------------------------------------------------------------------------
| This file is part of OpenBLT. OpenBLT is free software: you can redistribute it and/or
| modify it under the terms of the GNU General Public License as published by the Free
| Software Foundation, either version 3 of the License, or (at your option) any later
| version.
|
| OpenBLT is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
| without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
| PURPOSE. See the GNU General Public License for more details.
|
| You should have received a copy of the GNU General Public License along with OpenBLT.
| If not, see <http://www.gnu.org/licenses/>.
|
| A special exception to the GPL is included to allow you to distribute a combined work
| that includes OpenBLT without being obliged to provide the source code for any
| proprietary components. The exception text is included at the bottom of the license
| file <license.html>.
|
****************************************************************************************/

/****************************************************************************************
* Include files
****************************************************************************************/
#include <stdlib.h>
#include <reent.h>
#include <sys/stat.h>
#include "uart.h"


/****************************************************************************************
** NAME:           _read_r
** PARAMETER:      len number of character to read.
** RETURN VALUE:   number of characters read
** DESCRIPTION:    Reentrant function for reading data from a file. In this case the
**                 read is performed from the UART interface, so only the len parameter
**                 is used.
**
****************************************************************************************/
_ssize_t _read_r(struct _reent *r, int file, void *ptr, size_t len)
{
  char c;
  int  i;
  unsigned char *p;

  p = (unsigned char*)ptr;

  /* receive all characters with echo */
  for (i = 0; i < len; i++)
  {
    c = UartRxChar(1);

    *p++ = c;
    UartTxChar(c);

    /* was this a \n newline code? */
    if (c == 0x0D && i <= (len - 2))
    {
      /* automatically add cariage return after a new line */
      *p = 0x0A;
      UartTxChar(0x0A);
      return i + 2;
    }
  }
  return i;
} /*** end of _read_r ***/


/****************************************************************************************
** NAME:           _write_r
** PARAMETER:      len number of character to write
** RETURN VALUE:   number of characters written.
** DESCRIPTION:    Reentrant function for writing data from a file. In this case the
**                 write is performed to the UART interface, so only the len parameter
**                 is used.
**
****************************************************************************************/
_ssize_t _write_r(struct _reent *r, int file, const void *ptr, size_t len)
{
	int i;
	const unsigned char *p;
	
	p = (const unsigned char*) ptr;
	
	/* transmit all characters */
	for (i = 0; i < len; i++)
	{
		if (*p == '\n' )
		{
		  /* automatically add cariage return after a new line */
		  UartTxChar('\r');
		}
		UartTxChar(*p++);
	}
	
	return len;
} /*** end of _write_r ***/


/****************************************************************************************
** NAME:           _close_r
** PARAMETER:      none
** RETURN VALUE:   none
** DESCRIPTION:    Reentrant function for closing a file. Since UART is used, no further
**                 action is required here.
**
****************************************************************************************/
int _close_r(struct _reent *r, int file)
{
	return 0;
} /*** end of _close_r ***/


/****************************************************************************************
** NAME:           _lseek_r
** PARAMETER:      none
** RETURN VALUE:   none
** DESCRIPTION:    Reentrant function for obtaining the file pointer. Since UART is
**                 used, no further action is required here.
**
****************************************************************************************/
_off_t _lseek_r(struct _reent *r, int file, _off_t ptr,  int dir)
{
  /* always at the beginning of the file */
	return (_off_t)0;
} /*** end of _lseek_r ***/


/****************************************************************************************
 *
** NAME:           _fstat_r
** PARAMETER:      none
** RETURN VALUE:   none
** DESCRIPTION:    Reentrant function for setting the device mode.
**
****************************************************************************************/
int _fstat_r(struct _reent *r, int file, struct stat *st)
{
	/* set as character device */
	st->st_mode = S_IFCHR;	
	return 0;
} /*** end of _fstat_r ***/



/****************************************************************************************
** NAME:           _isatty_r
** PARAMETER:      none
** RETURN VALUE:   none
** DESCRIPTION:    Not supported
**
****************************************************************************************/
int _isatty_r(struct _reent *r, int file)
{
	return 1;
} /*** end of _isatty_r ***/


/**** Locally used variables. ****/
extern char end[];              /*  end is set in the linker command  */
      /* file and is the end of statically  */
      /* allocated data (thus start of heap). */



/****************************************************************************************
* External data declarations
****************************************************************************************/
/* these externals are declared by the linker */
extern unsigned long _heap;
extern unsigned long _eheap;


/****************************************************************************************
* Local data declarations
****************************************************************************************/
static char *heap_ptr = NULL;
static char  heap[512];

/****************************************************************************************
** NAME:           _sbrk_r
** PARAMETER:      none
** RETURN VALUE:   none
** DESCRIPTION:    Increments the heap pointer.
**
****************************************************************************************/
void * _sbrk_r(struct _reent *_s_r,  ptrdiff_t nbytes)
{
  char  *base;

  /* initialize the heap pointer if not yet done */
  if (heap_ptr == NULL)
  {
    /* set it to the current end of the heap */
    heap_ptr = &heap[0];
  }

  /* check if there is still room on the heap for this allocation */
  if ((unsigned long)(heap_ptr + nbytes) > (unsigned long)(heap + sizeof(heap)))
  {
    /* cannot allocate */
    return NULL;
  }

  /* remember current pointer value for the return value */
  base = heap_ptr;  /*  Point to end of heap.     */
  /* allocate the  */
  heap_ptr += nbytes; /*  Increase heap.        */

  return base;    /*  Return pointer to start of new heap area. */
} /*** end of _sbrk_r ***/


/*********************************** end of syscalls.c *********************************/

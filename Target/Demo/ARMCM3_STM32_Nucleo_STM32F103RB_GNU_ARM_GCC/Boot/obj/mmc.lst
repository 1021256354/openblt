   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"mmc.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.xchg_spi,"ax",%progbits
  19              		.align	2
  20              		.thumb
  21              		.thumb_func
  23              	xchg_spi:
  24              	.LFB33:
  25              		.file 1 "./lib/fatfs/mmc.c"
   1:./lib/fatfs/mmc.c **** /*------------------------------------------------------------------------/
   2:./lib/fatfs/mmc.c **** /  MMCv3/SDv1/SDv2 (in SPI mode) control module
   3:./lib/fatfs/mmc.c **** /-------------------------------------------------------------------------/
   4:./lib/fatfs/mmc.c **** /
   5:./lib/fatfs/mmc.c **** /  Copyright (C) 2013, ChaN, all right reserved.
   6:./lib/fatfs/mmc.c **** /
   7:./lib/fatfs/mmc.c **** / * This software is a free software and there is NO WARRANTY.
   8:./lib/fatfs/mmc.c **** / * No restriction on use. You can use, modify and redistribute it for
   9:./lib/fatfs/mmc.c **** /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
  10:./lib/fatfs/mmc.c **** / * Redistributions of source code must retain the above copyright notice.
  11:./lib/fatfs/mmc.c **** /
  12:./lib/fatfs/mmc.c **** /-------------------------------------------------------------------------*/
  13:./lib/fatfs/mmc.c **** 
  14:./lib/fatfs/mmc.c **** 
  15:./lib/fatfs/mmc.c **** /*
  16:./lib/fatfs/mmc.c ****  * This file was modified from a sample available from the FatFs
  17:./lib/fatfs/mmc.c ****  * web site. It was modified to work with a Olimex STM32-P103
  18:./lib/fatfs/mmc.c ****  * evaluation board.
  19:./lib/fatfs/mmc.c ****  *
  20:./lib/fatfs/mmc.c ****  */
  21:./lib/fatfs/mmc.c **** #include "diskio.h"
  22:./lib/fatfs/mmc.c **** #include "stm32f10x.h"                                /* STM32 registers               */
  23:./lib/fatfs/mmc.c **** #include "stm32f10x_conf.h"                           /* STM32 peripheral drivers      */
  24:./lib/fatfs/mmc.c **** #include "boot.h"
  25:./lib/fatfs/mmc.c **** 
  26:./lib/fatfs/mmc.c **** 
  27:./lib/fatfs/mmc.c **** 
  28:./lib/fatfs/mmc.c **** /*--------------------------------------------------------------------------
  29:./lib/fatfs/mmc.c **** 
  30:./lib/fatfs/mmc.c ****    Module Private Functions
  31:./lib/fatfs/mmc.c **** 
  32:./lib/fatfs/mmc.c **** ---------------------------------------------------------------------------*/
  33:./lib/fatfs/mmc.c **** 
  34:./lib/fatfs/mmc.c **** /* Definitions for MMC/SDC command */
  35:./lib/fatfs/mmc.c **** #define CMD0   (0)			/* GO_IDLE_STATE */
  36:./lib/fatfs/mmc.c **** #define CMD1   (1)			/* SEND_OP_COND */
  37:./lib/fatfs/mmc.c **** #define ACMD41 (41|0x80)	/* SEND_OP_COND (SDC) */
  38:./lib/fatfs/mmc.c **** #define CMD8   (8)			/* SEND_IF_COND */
  39:./lib/fatfs/mmc.c **** #define CMD9   (9)			/* SEND_CSD */
  40:./lib/fatfs/mmc.c **** #define CMD10  (10)			/* SEND_CID */
  41:./lib/fatfs/mmc.c **** #define CMD12  (12)			/* STOP_TRANSMISSION */
  42:./lib/fatfs/mmc.c **** #define ACMD13 (13|0x80)	/* SD_STATUS (SDC) */
  43:./lib/fatfs/mmc.c **** #define CMD16  (16)			/* SET_BLOCKLEN */
  44:./lib/fatfs/mmc.c **** #define CMD17  (17)			/* READ_SINGLE_BLOCK */
  45:./lib/fatfs/mmc.c **** #define CMD18  (18)			/* READ_MULTIPLE_BLOCK */
  46:./lib/fatfs/mmc.c **** #define CMD23  (23)			/* SET_BLOCK_COUNT */
  47:./lib/fatfs/mmc.c **** #define ACMD23 (23|0x80)	/* SET_WR_BLK_ERASE_COUNT (SDC) */
  48:./lib/fatfs/mmc.c **** #define CMD24  (24)			/* WRITE_BLOCK */
  49:./lib/fatfs/mmc.c **** #define CMD25  (25)			/* WRITE_MULTIPLE_BLOCK */
  50:./lib/fatfs/mmc.c **** #define CMD41  (41)			/* SEND_OP_COND (ACMD) */
  51:./lib/fatfs/mmc.c **** #define CMD55  (55)			/* APP_CMD */
  52:./lib/fatfs/mmc.c **** #define CMD58  (58)			/* READ_OCR */
  53:./lib/fatfs/mmc.c **** 
  54:./lib/fatfs/mmc.c **** 
  55:./lib/fatfs/mmc.c **** /* Control signals (Platform dependent) */
  56:./lib/fatfs/mmc.c **** #define CS_LOW()	  GPIO_ResetBits(GPIOB, GPIO_Pin_12)  /* MMC CS = L */
  57:./lib/fatfs/mmc.c **** #define	CS_HIGH()	  GPIO_SetBits(GPIOB, GPIO_Pin_12)  	/* MMC CS = H */
  58:./lib/fatfs/mmc.c **** 
  59:./lib/fatfs/mmc.c **** 
  60:./lib/fatfs/mmc.c **** 
  61:./lib/fatfs/mmc.c **** #define	FCLK_SLOW()			/* Set slow clock (100k-400k) */
  62:./lib/fatfs/mmc.c **** #define	FCLK_FAST()	set_max_speed()	/* Set fast clock (depends on the CSD) */
  63:./lib/fatfs/mmc.c **** 
  64:./lib/fatfs/mmc.c **** static volatile
  65:./lib/fatfs/mmc.c **** DSTATUS Stat = STA_NOINIT;	/* Disk status */
  66:./lib/fatfs/mmc.c **** 
  67:./lib/fatfs/mmc.c **** static
  68:./lib/fatfs/mmc.c **** UINT CardType;
  69:./lib/fatfs/mmc.c **** 
  70:./lib/fatfs/mmc.c **** 
  71:./lib/fatfs/mmc.c **** /*-----------------------------------------------------------------------*/
  72:./lib/fatfs/mmc.c **** /* Send 80 or so clock transitions with CS and DI held high. This is     */
  73:./lib/fatfs/mmc.c **** /* required after card power up to get it into SPI mode                  */
  74:./lib/fatfs/mmc.c **** /*-----------------------------------------------------------------------*/
  75:./lib/fatfs/mmc.c **** static
  76:./lib/fatfs/mmc.c **** void send_initial_clock_train(void)
  77:./lib/fatfs/mmc.c **** {
  78:./lib/fatfs/mmc.c ****   GPIO_InitTypeDef GPIO_InitStructure;
  79:./lib/fatfs/mmc.c ****   unsigned int i;
  80:./lib/fatfs/mmc.c **** 
  81:./lib/fatfs/mmc.c ****   /* Ensure CS is held high. */
  82:./lib/fatfs/mmc.c ****   CS_HIGH();
  83:./lib/fatfs/mmc.c **** 
  84:./lib/fatfs/mmc.c ****   /* Switch the SSI TX line to a GPIO and drive it high too. */
  85:./lib/fatfs/mmc.c ****   GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_15;
  86:./lib/fatfs/mmc.c ****   GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  87:./lib/fatfs/mmc.c ****   GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
  88:./lib/fatfs/mmc.c ****   GPIO_Init(GPIOB, &GPIO_InitStructure);
  89:./lib/fatfs/mmc.c ****   GPIO_SetBits(GPIOB, GPIO_Pin_15);
  90:./lib/fatfs/mmc.c **** 
  91:./lib/fatfs/mmc.c ****   /* Send 10 bytes over the SSI. This causes the clock to wiggle the */
  92:./lib/fatfs/mmc.c ****   /* required number of times. */
  93:./lib/fatfs/mmc.c ****   for(i = 0 ; i < 10 ; i++)
  94:./lib/fatfs/mmc.c ****   {
  95:./lib/fatfs/mmc.c ****     /* Loop while DR register in not empty */
  96:./lib/fatfs/mmc.c ****     while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_TXE) == RESET) { ; }
  97:./lib/fatfs/mmc.c **** 
  98:./lib/fatfs/mmc.c ****     /* Send byte through the SPI peripheral */
  99:./lib/fatfs/mmc.c ****     SPI_I2S_SendData(SPI2, 0xff);
 100:./lib/fatfs/mmc.c **** 
 101:./lib/fatfs/mmc.c ****     /* Wait to receive a byte */
 102:./lib/fatfs/mmc.c ****     while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_RXNE) == RESET) { ; }
 103:./lib/fatfs/mmc.c ****   }
 104:./lib/fatfs/mmc.c **** 
 105:./lib/fatfs/mmc.c ****   /* Revert to hardware control of the SSI TX line. */
 106:./lib/fatfs/mmc.c ****   GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_15;
 107:./lib/fatfs/mmc.c ****   GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 108:./lib/fatfs/mmc.c ****   GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF_PP;
 109:./lib/fatfs/mmc.c ****   GPIO_Init(GPIOB, &GPIO_InitStructure);
 110:./lib/fatfs/mmc.c **** }
 111:./lib/fatfs/mmc.c **** 
 112:./lib/fatfs/mmc.c **** 
 113:./lib/fatfs/mmc.c **** /*-----------------------------------------------------------------------*/
 114:./lib/fatfs/mmc.c **** /* Power Control  (Platform dependent)                                   */
 115:./lib/fatfs/mmc.c **** /*-----------------------------------------------------------------------*/
 116:./lib/fatfs/mmc.c **** /* When the target system does not support socket power control, there   */
 117:./lib/fatfs/mmc.c **** /* is nothing to do in these functions.                                  */
 118:./lib/fatfs/mmc.c **** 
 119:./lib/fatfs/mmc.c **** static
 120:./lib/fatfs/mmc.c **** void power_on (void)
 121:./lib/fatfs/mmc.c **** {
 122:./lib/fatfs/mmc.c ****   SPI_InitTypeDef  SPI_InitStructure;
 123:./lib/fatfs/mmc.c ****   GPIO_InitTypeDef GPIO_InitStructure;
 124:./lib/fatfs/mmc.c **** 
 125:./lib/fatfs/mmc.c ****   /*
 126:./lib/fatfs/mmc.c ****    * This doesn't really turn the power on, but initializes the
 127:./lib/fatfs/mmc.c ****    * SSI port and pins needed to talk to the card.
 128:./lib/fatfs/mmc.c ****    */
 129:./lib/fatfs/mmc.c **** 
 130:./lib/fatfs/mmc.c ****   /* Enable GPIO clock for CS */
 131:./lib/fatfs/mmc.c ****   RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
 132:./lib/fatfs/mmc.c ****   /* Enable SPI clock, SPI2: APB1 */
 133:./lib/fatfs/mmc.c ****   RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);
 134:./lib/fatfs/mmc.c ****   /* Configure I/O for Flash Chip select (PB12) */
 135:./lib/fatfs/mmc.c ****   GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_12;
 136:./lib/fatfs/mmc.c ****   GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
 137:./lib/fatfs/mmc.c ****   GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 138:./lib/fatfs/mmc.c ****   GPIO_Init(GPIOB, &GPIO_InitStructure);
 139:./lib/fatfs/mmc.c **** 
 140:./lib/fatfs/mmc.c ****   /* De-select the Card: Chip Select high */
 141:./lib/fatfs/mmc.c ****   GPIO_SetBits(GPIOB, GPIO_Pin_12);
 142:./lib/fatfs/mmc.c **** 
 143:./lib/fatfs/mmc.c ****   /* Configure SPI pins: SCK (PB13) and MOSI (PB15) with default alternate function (not re-mapped)
 144:./lib/fatfs/mmc.c ****   GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_13 | GPIO_Pin_15;
 145:./lib/fatfs/mmc.c ****   GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 146:./lib/fatfs/mmc.c ****   GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF_PP;
 147:./lib/fatfs/mmc.c ****   GPIO_Init(GPIOB, &GPIO_InitStructure);
 148:./lib/fatfs/mmc.c ****   /* Configure MISO (PB14) as Input with internal pull-up */
 149:./lib/fatfs/mmc.c ****   GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_14;
 150:./lib/fatfs/mmc.c ****   GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPU;
 151:./lib/fatfs/mmc.c ****   GPIO_Init(GPIOB, &GPIO_InitStructure);
 152:./lib/fatfs/mmc.c **** 
 153:./lib/fatfs/mmc.c ****   /* SPI configuration */
 154:./lib/fatfs/mmc.c ****   SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
 155:./lib/fatfs/mmc.c ****   SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
 156:./lib/fatfs/mmc.c ****   SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
 157:./lib/fatfs/mmc.c ****   SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
 158:./lib/fatfs/mmc.c ****   SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
 159:./lib/fatfs/mmc.c ****   SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
 160:./lib/fatfs/mmc.c ****   SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_256; // 72000kHz/256=281kHz < 400
 161:./lib/fatfs/mmc.c ****   SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
 162:./lib/fatfs/mmc.c ****   SPI_InitStructure.SPI_CRCPolynomial = 7;
 163:./lib/fatfs/mmc.c **** 
 164:./lib/fatfs/mmc.c ****   SPI_Init(SPI2, &SPI_InitStructure);
 165:./lib/fatfs/mmc.c ****   SPI_CalculateCRC(SPI2, DISABLE);
 166:./lib/fatfs/mmc.c ****   SPI_Cmd(SPI2, ENABLE);
 167:./lib/fatfs/mmc.c **** 
 168:./lib/fatfs/mmc.c ****     /* Set DI and CS high and apply more than 74 pulses to SCLK for the card */
 169:./lib/fatfs/mmc.c ****     /* to be able to accept a native command. */
 170:./lib/fatfs/mmc.c ****     send_initial_clock_train();
 171:./lib/fatfs/mmc.c **** 
 172:./lib/fatfs/mmc.c **** }
 173:./lib/fatfs/mmc.c **** // set the SSI speed to the max setting
 174:./lib/fatfs/mmc.c **** static
 175:./lib/fatfs/mmc.c **** void set_max_speed(void)
 176:./lib/fatfs/mmc.c **** {
 177:./lib/fatfs/mmc.c ****   SPI_InitTypeDef  SPI_InitStructure;
 178:./lib/fatfs/mmc.c **** 
 179:./lib/fatfs/mmc.c ****   /* Disable the SPI system */
 180:./lib/fatfs/mmc.c ****   SPI_Cmd(SPI2, DISABLE);
 181:./lib/fatfs/mmc.c **** 
 182:./lib/fatfs/mmc.c ****   /* MMC/SDC can work at the clock frequency up to 20/25MHz so pick a speed close to
 183:./lib/fatfs/mmc.c ****    * this but not higher
 184:./lib/fatfs/mmc.c ****    */
 185:./lib/fatfs/mmc.c ****   SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
 186:./lib/fatfs/mmc.c ****   SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
 187:./lib/fatfs/mmc.c ****   SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
 188:./lib/fatfs/mmc.c ****   SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
 189:./lib/fatfs/mmc.c ****   SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
 190:./lib/fatfs/mmc.c ****   SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
 191:./lib/fatfs/mmc.c ****   SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_4; // 72MHz/4=18MHz < 20MHz
 192:./lib/fatfs/mmc.c ****   SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
 193:./lib/fatfs/mmc.c ****   SPI_InitStructure.SPI_CRCPolynomial = 7;
 194:./lib/fatfs/mmc.c ****   SPI_Init(SPI2, &SPI_InitStructure);
 195:./lib/fatfs/mmc.c ****   SPI_CalculateCRC(SPI2, DISABLE);
 196:./lib/fatfs/mmc.c **** 
 197:./lib/fatfs/mmc.c ****   /* Enable the SPI system */
 198:./lib/fatfs/mmc.c ****   SPI_Cmd(SPI2, ENABLE);
 199:./lib/fatfs/mmc.c **** }
 200:./lib/fatfs/mmc.c **** 
 201:./lib/fatfs/mmc.c **** static
 202:./lib/fatfs/mmc.c **** void power_off (void)
 203:./lib/fatfs/mmc.c **** {
 204:./lib/fatfs/mmc.c **** 	Stat |= STA_NOINIT;	/* Force uninitialized */
 205:./lib/fatfs/mmc.c **** }
 206:./lib/fatfs/mmc.c **** 
 207:./lib/fatfs/mmc.c **** 
 208:./lib/fatfs/mmc.c **** /*-----------------------------------------------------------------------*/
 209:./lib/fatfs/mmc.c **** /* Transmit/Receive data to/from MMC via SPI  (Platform dependent)       */
 210:./lib/fatfs/mmc.c **** /*-----------------------------------------------------------------------*/
 211:./lib/fatfs/mmc.c **** 
 212:./lib/fatfs/mmc.c **** static
 213:./lib/fatfs/mmc.c **** BYTE xchg_spi (BYTE dat)
 214:./lib/fatfs/mmc.c **** {
  26              		.loc 1 214 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              	.LVL0:
  31 0000 38B5     		push	{r3, r4, r5, lr}
  32              		.cfi_def_cfa_offset 16
  33              		.cfi_offset 3, -16
  34              		.cfi_offset 4, -12
  35              		.cfi_offset 5, -8
  36              		.cfi_offset 14, -4
 215:./lib/fatfs/mmc.c ****   /* Send byte through the SPI peripheral */
 216:./lib/fatfs/mmc.c ****   SPI_I2S_SendData(SPI2, dat);
  37              		.loc 1 216 0
  38 0002 0146     		mov	r1, r0
  39 0004 0748     		ldr	r0, .L5
  40              	.LVL1:
  41 0006 FFF7FEFF 		bl	SPI_I2S_SendData
  42              	.LVL2:
 217:./lib/fatfs/mmc.c **** 
 218:./lib/fatfs/mmc.c ****   /* Wait to receive a byte */
 219:./lib/fatfs/mmc.c ****   while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_RXNE) == RESET) { ; }
  43              		.loc 1 219 0
  44 000a 064D     		ldr	r5, .L5
  45 000c 0124     		movs	r4, #1
  46              	.L2:
  47              		.loc 1 219 0 is_stmt 0 discriminator 1
  48 000e 2846     		mov	r0, r5
  49 0010 2146     		mov	r1, r4
  50 0012 FFF7FEFF 		bl	SPI_I2S_GetFlagStatus
  51              	.LVL3:
  52 0016 0028     		cmp	r0, #0
  53 0018 F9D0     		beq	.L2
 220:./lib/fatfs/mmc.c **** 
 221:./lib/fatfs/mmc.c ****   /* Return the byte read from the SPI bus */
 222:./lib/fatfs/mmc.c ****   return (BYTE)SPI_I2S_ReceiveData(SPI2);
  54              		.loc 1 222 0 is_stmt 1
  55 001a 0248     		ldr	r0, .L5
  56 001c FFF7FEFF 		bl	SPI_I2S_ReceiveData
  57              	.LVL4:
 223:./lib/fatfs/mmc.c **** }
  58              		.loc 1 223 0
  59 0020 C0B2     		uxtb	r0, r0
  60 0022 38BD     		pop	{r3, r4, r5, pc}
  61              	.L6:
  62              		.align	2
  63              	.L5:
  64 0024 00380040 		.word	1073756160
  65              		.cfi_endproc
  66              	.LFE33:
  68              		.section	.text.wait_ready,"ax",%progbits
  69              		.align	2
  70              		.thumb
  71              		.thumb_func
  73              	wait_ready:
  74              	.LFB35:
 224:./lib/fatfs/mmc.c **** 
 225:./lib/fatfs/mmc.c **** static
 226:./lib/fatfs/mmc.c **** void rcvr_spi_m (BYTE *dst)
 227:./lib/fatfs/mmc.c **** {
 228:./lib/fatfs/mmc.c ****     *dst = xchg_spi(0xFF);
 229:./lib/fatfs/mmc.c **** }
 230:./lib/fatfs/mmc.c **** 
 231:./lib/fatfs/mmc.c **** 
 232:./lib/fatfs/mmc.c **** /*-----------------------------------------------------------------------*/
 233:./lib/fatfs/mmc.c **** /* Wait for card ready                                                   */
 234:./lib/fatfs/mmc.c **** /*-----------------------------------------------------------------------*/
 235:./lib/fatfs/mmc.c **** 
 236:./lib/fatfs/mmc.c **** static
 237:./lib/fatfs/mmc.c **** int wait_ready (void)
 238:./lib/fatfs/mmc.c **** {
  75              		.loc 1 238 0
  76              		.cfi_startproc
  77              		@ args = 0, pretend = 0, frame = 0
  78              		@ frame_needed = 0, uses_anonymous_args = 0
  79 0000 70B5     		push	{r4, r5, r6, lr}
  80              		.cfi_def_cfa_offset 16
  81              		.cfi_offset 4, -16
  82              		.cfi_offset 5, -12
  83              		.cfi_offset 6, -8
  84              		.cfi_offset 14, -4
 239:./lib/fatfs/mmc.c **** 	BYTE d;
 240:./lib/fatfs/mmc.c ****   ULONG timeOutTime;
 241:./lib/fatfs/mmc.c ****   
 242:./lib/fatfs/mmc.c ****   /* set timeout for 500 ms from now */
 243:./lib/fatfs/mmc.c ****   timeOutTime = TimerGet() + 500;
  85              		.loc 1 243 0
  86 0002 FFF7FEFF 		bl	TimerGet
  87              	.LVL5:
  88 0006 00F5FA76 		add	r6, r0, #500
  89              	.LVL6:
 244:./lib/fatfs/mmc.c **** 
 245:./lib/fatfs/mmc.c **** 	do {
 246:./lib/fatfs/mmc.c **** 		d = xchg_spi(0xFF);
  90              		.loc 1 246 0
  91 000a FF25     		movs	r5, #255
  92              	.L9:
  93              		.loc 1 246 0 is_stmt 0 discriminator 2
  94 000c 2846     		mov	r0, r5
  95 000e FFF7FEFF 		bl	xchg_spi
  96              	.LVL7:
  97 0012 0446     		mov	r4, r0
  98              	.LVL8:
 247:./lib/fatfs/mmc.c **** 	} while ((d != 0xFF) && (TimerGet() < timeOutTime));
  99              		.loc 1 247 0 is_stmt 1 discriminator 2
 100 0014 FF28     		cmp	r0, #255
 101 0016 03D0     		beq	.L8
 102              		.loc 1 247 0 is_stmt 0 discriminator 1
 103 0018 FFF7FEFF 		bl	TimerGet
 104              	.LVL9:
 105 001c 8642     		cmp	r6, r0
 106 001e F5D8     		bhi	.L9
 107              	.L8:
 248:./lib/fatfs/mmc.c **** 
 249:./lib/fatfs/mmc.c **** 	return (d == 0xFF) ? 1 : 0;
 250:./lib/fatfs/mmc.c **** }
 108              		.loc 1 250 0 is_stmt 1
 109 0020 FF2C     		cmp	r4, #255
 110 0022 14BF     		ite	ne
 111 0024 0020     		movne	r0, #0
 112 0026 0120     		moveq	r0, #1
 113 0028 70BD     		pop	{r4, r5, r6, pc}
 114              		.cfi_endproc
 115              	.LFE35:
 117 002a 00BF     		.section	.text.deselect,"ax",%progbits
 118              		.align	2
 119              		.thumb
 120              		.thumb_func
 122              	deselect:
 123              	.LFB36:
 251:./lib/fatfs/mmc.c **** 
 252:./lib/fatfs/mmc.c **** 
 253:./lib/fatfs/mmc.c **** /*-----------------------------------------------------------------------*/
 254:./lib/fatfs/mmc.c **** /* Deselect the card and release SPI bus                                 */
 255:./lib/fatfs/mmc.c **** /*-----------------------------------------------------------------------*/
 256:./lib/fatfs/mmc.c **** 
 257:./lib/fatfs/mmc.c **** static
 258:./lib/fatfs/mmc.c **** void deselect (void)
 259:./lib/fatfs/mmc.c **** {
 124              		.loc 1 259 0
 125              		.cfi_startproc
 126              		@ args = 0, pretend = 0, frame = 0
 127              		@ frame_needed = 0, uses_anonymous_args = 0
 128 0000 08B5     		push	{r3, lr}
 129              		.cfi_def_cfa_offset 8
 130              		.cfi_offset 3, -8
 131              		.cfi_offset 14, -4
 260:./lib/fatfs/mmc.c **** 	CS_HIGH();
 132              		.loc 1 260 0
 133 0002 0448     		ldr	r0, .L14
 134 0004 4FF48051 		mov	r1, #4096
 135 0008 FFF7FEFF 		bl	GPIO_SetBits
 136              	.LVL10:
 261:./lib/fatfs/mmc.c **** 	xchg_spi(0xFF);		/* Dummy clock (force DO hi-z for multiple slave SPI) */
 137              		.loc 1 261 0
 138 000c FF20     		movs	r0, #255
 139 000e FFF7FEFF 		bl	xchg_spi
 140              	.LVL11:
 141 0012 08BD     		pop	{r3, pc}
 142              	.L15:
 143              		.align	2
 144              	.L14:
 145 0014 000C0140 		.word	1073810432
 146              		.cfi_endproc
 147              	.LFE36:
 149              		.section	.text.select,"ax",%progbits
 150              		.align	2
 151              		.thumb
 152              		.thumb_func
 154              	select:
 155              	.LFB37:
 262:./lib/fatfs/mmc.c **** }
 263:./lib/fatfs/mmc.c **** 
 264:./lib/fatfs/mmc.c **** 
 265:./lib/fatfs/mmc.c **** 
 266:./lib/fatfs/mmc.c **** /*-----------------------------------------------------------------------*/
 267:./lib/fatfs/mmc.c **** /* Select the card and wait ready                                        */
 268:./lib/fatfs/mmc.c **** /*-----------------------------------------------------------------------*/
 269:./lib/fatfs/mmc.c **** 
 270:./lib/fatfs/mmc.c **** static
 271:./lib/fatfs/mmc.c **** int select (void)	/* 1:Successful, 0:Timeout */
 272:./lib/fatfs/mmc.c **** {
 156              		.loc 1 272 0
 157              		.cfi_startproc
 158              		@ args = 0, pretend = 0, frame = 0
 159              		@ frame_needed = 0, uses_anonymous_args = 0
 160 0000 10B5     		push	{r4, lr}
 161              		.cfi_def_cfa_offset 8
 162              		.cfi_offset 4, -8
 163              		.cfi_offset 14, -4
 273:./lib/fatfs/mmc.c **** 	CS_LOW();
 164              		.loc 1 273 0
 165 0002 0948     		ldr	r0, .L20
 166 0004 4FF48051 		mov	r1, #4096
 167 0008 FFF7FEFF 		bl	GPIO_ResetBits
 168              	.LVL12:
 274:./lib/fatfs/mmc.c **** 	xchg_spi(0xFF);		/* Dummy clock (force DO enabled) */
 169              		.loc 1 274 0
 170 000c FF20     		movs	r0, #255
 171 000e FFF7FEFF 		bl	xchg_spi
 172              	.LVL13:
 275:./lib/fatfs/mmc.c **** 
 276:./lib/fatfs/mmc.c **** 	if (wait_ready()) return 1;	/* OK */
 173              		.loc 1 276 0
 174 0012 FFF7FEFF 		bl	wait_ready
 175              	.LVL14:
 176 0016 18B9     		cbnz	r0, .L18
 177 0018 0446     		mov	r4, r0
 277:./lib/fatfs/mmc.c **** 	deselect();
 178              		.loc 1 277 0
 179 001a FFF7FEFF 		bl	deselect
 180              	.LVL15:
 278:./lib/fatfs/mmc.c **** 	return 0;	/* Timeout */
 181              		.loc 1 278 0
 182 001e 00E0     		b	.L17
 183              	.L18:
 276:./lib/fatfs/mmc.c **** 	deselect();
 184              		.loc 1 276 0
 185 0020 0124     		movs	r4, #1
 186              	.L17:
 279:./lib/fatfs/mmc.c **** }
 187              		.loc 1 279 0
 188 0022 2046     		mov	r0, r4
 189 0024 10BD     		pop	{r4, pc}
 190              	.L21:
 191 0026 00BF     		.align	2
 192              	.L20:
 193 0028 000C0140 		.word	1073810432
 194              		.cfi_endproc
 195              	.LFE37:
 197              		.section	.text.send_cmd,"ax",%progbits
 198              		.align	2
 199              		.thumb
 200              		.thumb_func
 202              	send_cmd:
 203              	.LFB40:
 280:./lib/fatfs/mmc.c **** 
 281:./lib/fatfs/mmc.c **** 
 282:./lib/fatfs/mmc.c **** 
 283:./lib/fatfs/mmc.c **** /*-----------------------------------------------------------------------*/
 284:./lib/fatfs/mmc.c **** /* Receive a data packet from MMC                                        */
 285:./lib/fatfs/mmc.c **** /*-----------------------------------------------------------------------*/
 286:./lib/fatfs/mmc.c **** 
 287:./lib/fatfs/mmc.c **** static
 288:./lib/fatfs/mmc.c **** int rcvr_datablock (	/* 1:OK, 0:Failed */
 289:./lib/fatfs/mmc.c **** 	BYTE *buff,			/* Data buffer to store received data */
 290:./lib/fatfs/mmc.c **** 	UINT btr			/* Byte count (must be multiple of 4) */
 291:./lib/fatfs/mmc.c **** )
 292:./lib/fatfs/mmc.c **** {
 293:./lib/fatfs/mmc.c **** 	BYTE token;
 294:./lib/fatfs/mmc.c ****   ULONG timeOutTime;
 295:./lib/fatfs/mmc.c **** 
 296:./lib/fatfs/mmc.c ****   /* set timeout for 100 ms from now */
 297:./lib/fatfs/mmc.c ****   timeOutTime = TimerGet() + 100;
 298:./lib/fatfs/mmc.c **** 
 299:./lib/fatfs/mmc.c **** 	do {							/* Wait for data packet in timeout of 100ms */
 300:./lib/fatfs/mmc.c **** 		token = xchg_spi(0xFF);
 301:./lib/fatfs/mmc.c **** 	} while ((token == 0xFF) && (TimerGet() < timeOutTime));
 302:./lib/fatfs/mmc.c **** 
 303:./lib/fatfs/mmc.c **** 	if(token != 0xFE) return 0;		/* If not valid data token, retutn with error */
 304:./lib/fatfs/mmc.c ****   
 305:./lib/fatfs/mmc.c ****     do {                            /* Receive the data block into buffer */
 306:./lib/fatfs/mmc.c ****         rcvr_spi_m(buff++);
 307:./lib/fatfs/mmc.c ****         rcvr_spi_m(buff++);
 308:./lib/fatfs/mmc.c ****     } while (btr -= 2);
 309:./lib/fatfs/mmc.c **** 	xchg_spi(0xFF);					/* Discard CRC */
 310:./lib/fatfs/mmc.c **** 	xchg_spi(0xFF);
 311:./lib/fatfs/mmc.c **** 
 312:./lib/fatfs/mmc.c **** 	return 1;						/* Return with success */
 313:./lib/fatfs/mmc.c **** }
 314:./lib/fatfs/mmc.c **** 
 315:./lib/fatfs/mmc.c **** 
 316:./lib/fatfs/mmc.c **** 
 317:./lib/fatfs/mmc.c **** /*-----------------------------------------------------------------------*/
 318:./lib/fatfs/mmc.c **** /* Send a data packet to MMC                                             */
 319:./lib/fatfs/mmc.c **** /*-----------------------------------------------------------------------*/
 320:./lib/fatfs/mmc.c **** 
 321:./lib/fatfs/mmc.c **** #if _USE_WRITE
 322:./lib/fatfs/mmc.c **** static
 323:./lib/fatfs/mmc.c **** int xmit_datablock (	/* 1:OK, 0:Failed */
 324:./lib/fatfs/mmc.c **** 	const BYTE *buff,	/* 512 byte data block to be transmitted */
 325:./lib/fatfs/mmc.c **** 	BYTE token			/* Data token */
 326:./lib/fatfs/mmc.c **** )
 327:./lib/fatfs/mmc.c **** {
 328:./lib/fatfs/mmc.c ****     BYTE resp;
 329:./lib/fatfs/mmc.c ****     UINT wc;
 330:./lib/fatfs/mmc.c **** 
 331:./lib/fatfs/mmc.c **** 
 332:./lib/fatfs/mmc.c **** 	if (!wait_ready()) return 0;
 333:./lib/fatfs/mmc.c **** 
 334:./lib/fatfs/mmc.c **** 	xchg_spi(token);		/* Xmit a token */
 335:./lib/fatfs/mmc.c **** 	if (token != 0xFD) {	/* Not StopTran token */
 336:./lib/fatfs/mmc.c ****         wc = 512;
 337:./lib/fatfs/mmc.c ****         do {                            /* Xmit the 512 byte data block to MMC */
 338:./lib/fatfs/mmc.c ****             xchg_spi(*buff++);
 339:./lib/fatfs/mmc.c ****             xchg_spi(*buff++);
 340:./lib/fatfs/mmc.c ****         } while (wc -= 2);
 341:./lib/fatfs/mmc.c **** 		xchg_spi(0xFF);				/* CRC (Dummy) */
 342:./lib/fatfs/mmc.c **** 		xchg_spi(0xFF);
 343:./lib/fatfs/mmc.c **** 		resp = xchg_spi(0xFF);		/* Receive a data response */
 344:./lib/fatfs/mmc.c **** 		if ((resp & 0x1F) != 0x05)	/* If not accepted, return with error */
 345:./lib/fatfs/mmc.c **** 			return 0;
 346:./lib/fatfs/mmc.c **** 	}
 347:./lib/fatfs/mmc.c **** 
 348:./lib/fatfs/mmc.c **** 	return 1;
 349:./lib/fatfs/mmc.c **** }
 350:./lib/fatfs/mmc.c **** #endif
 351:./lib/fatfs/mmc.c **** 
 352:./lib/fatfs/mmc.c **** 
 353:./lib/fatfs/mmc.c **** 
 354:./lib/fatfs/mmc.c **** /*-----------------------------------------------------------------------*/
 355:./lib/fatfs/mmc.c **** /* Send a command packet to MMC                                          */
 356:./lib/fatfs/mmc.c **** /*-----------------------------------------------------------------------*/
 357:./lib/fatfs/mmc.c **** 
 358:./lib/fatfs/mmc.c **** static
 359:./lib/fatfs/mmc.c **** BYTE send_cmd (
 360:./lib/fatfs/mmc.c **** 	BYTE cmd,		/* Command byte */
 361:./lib/fatfs/mmc.c **** 	DWORD arg		/* Argument */
 362:./lib/fatfs/mmc.c **** )
 363:./lib/fatfs/mmc.c **** {
 204              		.loc 1 363 0
 205              		.cfi_startproc
 206              		@ args = 0, pretend = 0, frame = 0
 207              		@ frame_needed = 0, uses_anonymous_args = 0
 208              	.LVL16:
 209 0000 38B5     		push	{r3, r4, r5, lr}
 210              		.cfi_def_cfa_offset 16
 211              		.cfi_offset 3, -16
 212              		.cfi_offset 4, -12
 213              		.cfi_offset 5, -8
 214              		.cfi_offset 14, -4
 215 0002 0446     		mov	r4, r0
 216 0004 0D46     		mov	r5, r1
 364:./lib/fatfs/mmc.c **** 	BYTE n, res;
 365:./lib/fatfs/mmc.c **** 
 366:./lib/fatfs/mmc.c **** 
 367:./lib/fatfs/mmc.c **** 	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
 217              		.loc 1 367 0
 218 0006 10F0800F 		tst	r0, #128
 219 000a 07D0     		beq	.L23
 220              	.LVL17:
 368:./lib/fatfs/mmc.c **** 		cmd &= 0x7F;
 369:./lib/fatfs/mmc.c **** 		res = send_cmd(CMD55, 0);
 221              		.loc 1 369 0
 222 000c 3720     		movs	r0, #55
 223 000e 0021     		movs	r1, #0
 224              	.LVL18:
 225 0010 FFF7F6FF 		bl	send_cmd
 226              	.LVL19:
 370:./lib/fatfs/mmc.c **** 		if (res > 1) return res;
 227              		.loc 1 370 0
 228 0014 0128     		cmp	r0, #1
 229 0016 3AD8     		bhi	.L33
 368:./lib/fatfs/mmc.c **** 		cmd &= 0x7F;
 230              		.loc 1 368 0
 231 0018 04F07F04 		and	r4, r4, #127
 232              	.LVL20:
 233              	.L23:
 371:./lib/fatfs/mmc.c **** 	}
 372:./lib/fatfs/mmc.c **** 
 373:./lib/fatfs/mmc.c **** 	/* Select the card and wait for ready */
 374:./lib/fatfs/mmc.c **** 	deselect();
 234              		.loc 1 374 0
 235 001c FFF7FEFF 		bl	deselect
 236              	.LVL21:
 375:./lib/fatfs/mmc.c **** 	if (!select()) return 0xFF;
 237              		.loc 1 375 0
 238 0020 FFF7FEFF 		bl	select
 239              	.LVL22:
 240 0024 48B3     		cbz	r0, .L30
 376:./lib/fatfs/mmc.c **** 
 377:./lib/fatfs/mmc.c **** 	/* Send command packet */
 378:./lib/fatfs/mmc.c **** 	xchg_spi(0x40 | cmd);			/* Start + Command index */
 241              		.loc 1 378 0
 242 0026 44F04000 		orr	r0, r4, #64
 243 002a FFF7FEFF 		bl	xchg_spi
 244              	.LVL23:
 379:./lib/fatfs/mmc.c **** 	xchg_spi((BYTE)(arg >> 24));	/* Argument[31..24] */
 245              		.loc 1 379 0
 246 002e 280E     		lsrs	r0, r5, #24
 247 0030 FFF7FEFF 		bl	xchg_spi
 248              	.LVL24:
 380:./lib/fatfs/mmc.c **** 	xchg_spi((BYTE)(arg >> 16));	/* Argument[23..16] */
 249              		.loc 1 380 0
 250 0034 C5F30740 		ubfx	r0, r5, #16, #8
 251 0038 FFF7FEFF 		bl	xchg_spi
 252              	.LVL25:
 381:./lib/fatfs/mmc.c **** 	xchg_spi((BYTE)(arg >> 8));		/* Argument[15..8] */
 253              		.loc 1 381 0
 254 003c C5F30720 		ubfx	r0, r5, #8, #8
 255 0040 FFF7FEFF 		bl	xchg_spi
 256              	.LVL26:
 382:./lib/fatfs/mmc.c **** 	xchg_spi((BYTE)arg);			/* Argument[7..0] */
 257              		.loc 1 382 0
 258 0044 E8B2     		uxtb	r0, r5
 259 0046 FFF7FEFF 		bl	xchg_spi
 260              	.LVL27:
 383:./lib/fatfs/mmc.c **** 	n = 0x01;						/* Dummy CRC + Stop */
 384:./lib/fatfs/mmc.c **** 	if (cmd == CMD0) n = 0x95;		/* Valid CRC for CMD0(0) + Stop */
 261              		.loc 1 384 0
 262 004a E4B1     		cbz	r4, .L25
 385:./lib/fatfs/mmc.c **** 	if (cmd == CMD8) n = 0x87;		/* Valid CRC for CMD8(0x1AA) + Stop */
 263              		.loc 1 385 0
 264 004c 082C     		cmp	r4, #8
 265 004e 16D0     		beq	.L26
 386:./lib/fatfs/mmc.c **** 	xchg_spi(n);
 266              		.loc 1 386 0
 267 0050 0120     		movs	r0, #1
 268 0052 FFF7FEFF 		bl	xchg_spi
 269              	.LVL28:
 387:./lib/fatfs/mmc.c **** 
 388:./lib/fatfs/mmc.c **** 	/* Receive command response */
 389:./lib/fatfs/mmc.c **** 	if (cmd == CMD12) xchg_spi(0xFF);	/* Skip a stuff byte on stop to read */
 270              		.loc 1 389 0
 271 0056 0C2C     		cmp	r4, #12
 272 0058 02D1     		bne	.L27
 273              		.loc 1 389 0 is_stmt 0 discriminator 1
 274 005a FF20     		movs	r0, #255
 275 005c FFF7FEFF 		bl	xchg_spi
 276              	.LVL29:
 277              	.L27:
 363:./lib/fatfs/mmc.c **** 	BYTE n, res;
 278              		.loc 1 363 0 is_stmt 1 discriminator 2
 279 0060 0A24     		movs	r4, #10
 280              	.LVL30:
 390:./lib/fatfs/mmc.c **** 	n = 10;							/* Wait for a valid response in timeout of 10 attempts */
 391:./lib/fatfs/mmc.c **** 	do
 392:./lib/fatfs/mmc.c **** 		res = xchg_spi(0xFF);
 281              		.loc 1 392 0 discriminator 2
 282 0062 FF25     		movs	r5, #255
 283              	.LVL31:
 284              	.L28:
 285 0064 2846     		mov	r0, r5
 286 0066 FFF7FEFF 		bl	xchg_spi
 287              	.LVL32:
 393:./lib/fatfs/mmc.c **** 	while ((res & 0x80) && --n);
 288              		.loc 1 393 0 discriminator 2
 289 006a 10F0800F 		tst	r0, #128
 290 006e 0ED0     		beq	.L33
 291              	.LVL33:
 292 0070 631E     		subs	r3, r4, #1
 293              		.loc 1 393 0 is_stmt 0 discriminator 1
 294 0072 13F0FF04 		ands	r4, r3, #255
 295              	.LVL34:
 296 0076 F5D1     		bne	.L28
 297 0078 38BD     		pop	{r3, r4, r5, pc}
 298              	.LVL35:
 299              	.L30:
 375:./lib/fatfs/mmc.c **** 
 300              		.loc 1 375 0 is_stmt 1
 301 007a FF20     		movs	r0, #255
 302 007c 38BD     		pop	{r3, r4, r5, pc}
 303              	.LVL36:
 304              	.L26:
 386:./lib/fatfs/mmc.c **** 
 305              		.loc 1 386 0
 306 007e 8720     		movs	r0, #135
 307 0080 FFF7FEFF 		bl	xchg_spi
 308              	.LVL37:
 309 0084 ECE7     		b	.L27
 310              	.LVL38:
 311              	.L25:
 312 0086 9520     		movs	r0, #149
 313 0088 FFF7FEFF 		bl	xchg_spi
 314              	.LVL39:
 315 008c E8E7     		b	.L27
 316              	.LVL40:
 317              	.L33:
 394:./lib/fatfs/mmc.c **** 
 395:./lib/fatfs/mmc.c **** 	return res;			/* Return with the response value */
 396:./lib/fatfs/mmc.c **** }
 318              		.loc 1 396 0
 319 008e 38BD     		pop	{r3, r4, r5, pc}
 320              		.cfi_endproc
 321              	.LFE40:
 323              		.section	.text.xmit_datablock,"ax",%progbits
 324              		.align	2
 325              		.thumb
 326              		.thumb_func
 328              	xmit_datablock:
 329              	.LFB39:
 327:./lib/fatfs/mmc.c ****     BYTE resp;
 330              		.loc 1 327 0
 331              		.cfi_startproc
 332              		@ args = 0, pretend = 0, frame = 0
 333              		@ frame_needed = 0, uses_anonymous_args = 0
 334              	.LVL41:
 335 0000 38B5     		push	{r3, r4, r5, lr}
 336              		.cfi_def_cfa_offset 16
 337              		.cfi_offset 3, -16
 338              		.cfi_offset 4, -12
 339              		.cfi_offset 5, -8
 340              		.cfi_offset 14, -4
 341 0002 0546     		mov	r5, r0
 342 0004 0C46     		mov	r4, r1
 332:./lib/fatfs/mmc.c **** 
 343              		.loc 1 332 0
 344 0006 FFF7FEFF 		bl	wait_ready
 345              	.LVL42:
 346 000a 0346     		mov	r3, r0
 347 000c 18B3     		cbz	r0, .L36
 334:./lib/fatfs/mmc.c **** 	if (token != 0xFD) {	/* Not StopTran token */
 348              		.loc 1 334 0
 349 000e 2046     		mov	r0, r4
 350 0010 FFF7FEFF 		bl	xchg_spi
 351              	.LVL43:
 335:./lib/fatfs/mmc.c ****         wc = 512;
 352              		.loc 1 335 0
 353 0014 FD2C     		cmp	r4, #253
 354 0016 1DD0     		beq	.L38
 355 0018 AC1C     		adds	r4, r5, #2
 356 001a 05F20225 		addw	r5, r5, #514
 357              	.LVL44:
 358              	.L37:
 338:./lib/fatfs/mmc.c ****             xchg_spi(*buff++);
 359              		.loc 1 338 0 discriminator 1
 360 001e 14F8020C 		ldrb	r0, [r4, #-2]	@ zero_extendqisi2
 361 0022 FFF7FEFF 		bl	xchg_spi
 362              	.LVL45:
 339:./lib/fatfs/mmc.c ****         } while (wc -= 2);
 363              		.loc 1 339 0 discriminator 1
 364 0026 14F8010C 		ldrb	r0, [r4, #-1]	@ zero_extendqisi2
 365 002a FFF7FEFF 		bl	xchg_spi
 366              	.LVL46:
 367 002e 0234     		adds	r4, r4, #2
 368              	.LVL47:
 340:./lib/fatfs/mmc.c **** 		xchg_spi(0xFF);				/* CRC (Dummy) */
 369              		.loc 1 340 0 discriminator 1
 370 0030 AC42     		cmp	r4, r5
 371 0032 F4D1     		bne	.L37
 341:./lib/fatfs/mmc.c **** 		xchg_spi(0xFF);
 372              		.loc 1 341 0
 373 0034 FF20     		movs	r0, #255
 374 0036 FFF7FEFF 		bl	xchg_spi
 375              	.LVL48:
 342:./lib/fatfs/mmc.c **** 		resp = xchg_spi(0xFF);		/* Receive a data response */
 376              		.loc 1 342 0
 377 003a FF20     		movs	r0, #255
 378 003c FFF7FEFF 		bl	xchg_spi
 379              	.LVL49:
 343:./lib/fatfs/mmc.c **** 		if ((resp & 0x1F) != 0x05)	/* If not accepted, return with error */
 380              		.loc 1 343 0
 381 0040 FF20     		movs	r0, #255
 382 0042 FFF7FEFF 		bl	xchg_spi
 383              	.LVL50:
 344:./lib/fatfs/mmc.c **** 			return 0;
 384              		.loc 1 344 0
 385 0046 00F01F00 		and	r0, r0, #31
 386              	.LVL51:
 387 004a 0528     		cmp	r0, #5
 388 004c 14BF     		ite	ne
 389 004e 0023     		movne	r3, #0
 390 0050 0123     		moveq	r3, #1
 391 0052 00E0     		b	.L36
 392              	.LVL52:
 393              	.L38:
 348:./lib/fatfs/mmc.c **** }
 394              		.loc 1 348 0
 395 0054 0123     		movs	r3, #1
 396              	.LVL53:
 397              	.L36:
 349:./lib/fatfs/mmc.c **** #endif
 398              		.loc 1 349 0
 399 0056 1846     		mov	r0, r3
 400 0058 38BD     		pop	{r3, r4, r5, pc}
 401              		.cfi_endproc
 402              	.LFE39:
 404 005a 00BF     		.section	.text.rcvr_datablock,"ax",%progbits
 405              		.align	2
 406              		.thumb
 407              		.thumb_func
 409              	rcvr_datablock:
 410              	.LFB38:
 292:./lib/fatfs/mmc.c **** 	BYTE token;
 411              		.loc 1 292 0
 412              		.cfi_startproc
 413              		@ args = 0, pretend = 0, frame = 0
 414              		@ frame_needed = 0, uses_anonymous_args = 0
 415              	.LVL54:
 416 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 417              		.cfi_def_cfa_offset 24
 418              		.cfi_offset 3, -24
 419              		.cfi_offset 4, -20
 420              		.cfi_offset 5, -16
 421              		.cfi_offset 6, -12
 422              		.cfi_offset 7, -8
 423              		.cfi_offset 14, -4
 424 0002 0446     		mov	r4, r0
 425 0004 0D46     		mov	r5, r1
 297:./lib/fatfs/mmc.c **** 
 426              		.loc 1 297 0
 427 0006 FFF7FEFF 		bl	TimerGet
 428              	.LVL55:
 429 000a 00F16407 		add	r7, r0, #100
 430              	.LVL56:
 300:./lib/fatfs/mmc.c **** 	} while ((token == 0xFF) && (TimerGet() < timeOutTime));
 431              		.loc 1 300 0
 432 000e FF26     		movs	r6, #255
 433              	.L43:
 300:./lib/fatfs/mmc.c **** 	} while ((token == 0xFF) && (TimerGet() < timeOutTime));
 434              		.loc 1 300 0 is_stmt 0 discriminator 2
 435 0010 3046     		mov	r0, r6
 436 0012 FFF7FEFF 		bl	xchg_spi
 437              	.LVL57:
 301:./lib/fatfs/mmc.c **** 
 438              		.loc 1 301 0 is_stmt 1 discriminator 2
 439 0016 FF28     		cmp	r0, #255
 440 0018 05D1     		bne	.L42
 301:./lib/fatfs/mmc.c **** 
 441              		.loc 1 301 0 is_stmt 0 discriminator 1
 442 001a FFF7FEFF 		bl	TimerGet
 443              	.LVL58:
 444 001e 8742     		cmp	r7, r0
 445 0020 F6D8     		bhi	.L43
 303:./lib/fatfs/mmc.c ****   
 446              		.loc 1 303 0 is_stmt 1
 447 0022 0020     		movs	r0, #0
 448 0024 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 449              	.LVL59:
 450              	.L42:
 451 0026 FE28     		cmp	r0, #254
 452 0028 16D1     		bne	.L46
 453 002a 0234     		adds	r4, r4, #2
 454              	.LVL60:
 455              	.LBB6:
 456              	.LBB7:
 228:./lib/fatfs/mmc.c **** }
 457              		.loc 1 228 0
 458 002c FF26     		movs	r6, #255
 459              	.LVL61:
 460              	.L45:
 228:./lib/fatfs/mmc.c **** }
 461              		.loc 1 228 0 is_stmt 0 discriminator 1
 462 002e 3046     		mov	r0, r6
 463 0030 FFF7FEFF 		bl	xchg_spi
 464              	.LVL62:
 465 0034 04F8020C 		strb	r0, [r4, #-2]
 466              	.LVL63:
 467              	.LBE7:
 468              	.LBE6:
 469              	.LBB8:
 470              	.LBB9:
 471 0038 3046     		mov	r0, r6
 472 003a FFF7FEFF 		bl	xchg_spi
 473              	.LVL64:
 474 003e 04F8010C 		strb	r0, [r4, #-1]
 475              	.LVL65:
 476 0042 0234     		adds	r4, r4, #2
 477              	.LVL66:
 478              	.LBE9:
 479              	.LBE8:
 308:./lib/fatfs/mmc.c **** 	xchg_spi(0xFF);					/* Discard CRC */
 480              		.loc 1 308 0 is_stmt 1 discriminator 1
 481 0044 023D     		subs	r5, r5, #2
 482              	.LVL67:
 483 0046 F2D1     		bne	.L45
 309:./lib/fatfs/mmc.c **** 	xchg_spi(0xFF);
 484              		.loc 1 309 0
 485 0048 FF20     		movs	r0, #255
 486 004a FFF7FEFF 		bl	xchg_spi
 487              	.LVL68:
 310:./lib/fatfs/mmc.c **** 
 488              		.loc 1 310 0
 489 004e FF20     		movs	r0, #255
 490 0050 FFF7FEFF 		bl	xchg_spi
 491              	.LVL69:
 312:./lib/fatfs/mmc.c **** }
 492              		.loc 1 312 0
 493 0054 0120     		movs	r0, #1
 494 0056 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 495              	.LVL70:
 496              	.L46:
 303:./lib/fatfs/mmc.c ****   
 497              		.loc 1 303 0
 498 0058 0020     		movs	r0, #0
 499              	.LVL71:
 313:./lib/fatfs/mmc.c **** 
 500              		.loc 1 313 0
 501 005a F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 502              		.cfi_endproc
 503              	.LFE38:
 505              		.section	.text.disk_initialize,"ax",%progbits
 506              		.align	2
 507              		.global	disk_initialize
 508              		.thumb
 509              		.thumb_func
 511              	disk_initialize:
 512              	.LFB41:
 397:./lib/fatfs/mmc.c **** 
 398:./lib/fatfs/mmc.c **** 
 399:./lib/fatfs/mmc.c **** 
 400:./lib/fatfs/mmc.c **** /*--------------------------------------------------------------------------
 401:./lib/fatfs/mmc.c **** 
 402:./lib/fatfs/mmc.c ****    Public Functions
 403:./lib/fatfs/mmc.c **** 
 404:./lib/fatfs/mmc.c **** ---------------------------------------------------------------------------*/
 405:./lib/fatfs/mmc.c **** 
 406:./lib/fatfs/mmc.c **** 
 407:./lib/fatfs/mmc.c **** /*-----------------------------------------------------------------------*/
 408:./lib/fatfs/mmc.c **** /* Initialize Disk Drive                                                 */
 409:./lib/fatfs/mmc.c **** /*-----------------------------------------------------------------------*/
 410:./lib/fatfs/mmc.c **** 
 411:./lib/fatfs/mmc.c **** DSTATUS disk_initialize (
 412:./lib/fatfs/mmc.c **** 	BYTE pdrv		/* Physical drive nmuber (0) */
 413:./lib/fatfs/mmc.c **** )
 414:./lib/fatfs/mmc.c **** {
 513              		.loc 1 414 0
 514              		.cfi_startproc
 515              		@ args = 0, pretend = 0, frame = 32
 516              		@ frame_needed = 0, uses_anonymous_args = 0
 517              	.LVL72:
 415:./lib/fatfs/mmc.c **** 	BYTE n, cmd, ty, ocr[4];
 416:./lib/fatfs/mmc.c ****   ULONG timeOutTime;
 417:./lib/fatfs/mmc.c **** 
 418:./lib/fatfs/mmc.c **** 
 419:./lib/fatfs/mmc.c **** 	if (pdrv) return STA_NOINIT;		/* Supports only single drive */
 518              		.loc 1 419 0
 519 0000 0028     		cmp	r0, #0
 520 0002 40F05A81 		bne	.L69
 420:./lib/fatfs/mmc.c **** 	if (Stat & STA_NODISK) return Stat;	/* No card in the socket */
 521              		.loc 1 420 0
 522 0006 B24B     		ldr	r3, .L84
 523 0008 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 524 000a 13F0020F 		tst	r3, #2
 525 000e 03D0     		beq	.L52
 526              		.loc 1 420 0 is_stmt 0 discriminator 1
 527 0010 AF4B     		ldr	r3, .L84
 528 0012 1878     		ldrb	r0, [r3]	@ zero_extendqisi2
 529              	.LVL73:
 530 0014 C0B2     		uxtb	r0, r0
 421:./lib/fatfs/mmc.c **** 
 422:./lib/fatfs/mmc.c ****     power_on();                            /* Force socket power on */
 423:./lib/fatfs/mmc.c **** 
 424:./lib/fatfs/mmc.c ****      CS_LOW();                /* CS = L */
 425:./lib/fatfs/mmc.c **** 
 426:./lib/fatfs/mmc.c **** 	ty = 0;
 427:./lib/fatfs/mmc.c **** 	if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
 428:./lib/fatfs/mmc.c ****     timeOutTime = TimerGet() + 1000; /* Initialization timeout of 1000 msec */
 429:./lib/fatfs/mmc.c **** 
 430:./lib/fatfs/mmc.c **** 		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
 431:./lib/fatfs/mmc.c **** 			for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);			/* Get trailing return value of R7 resp */
 432:./lib/fatfs/mmc.c **** 			if (ocr[2] == 0x01 && ocr[3] == 0xAA) {				/* The card can work at vdd range of 2.7-3.6V */
 433:./lib/fatfs/mmc.c **** 				while ((TimerGet() < timeOutTime) && send_cmd(ACMD41, 0x40000000));	/* Wait for leaving idle st
 434:./lib/fatfs/mmc.c **** 				if ((TimerGet() < timeOutTime) && send_cmd(CMD58, 0) == 0) {			/* Check CCS bit in the OCR */
 435:./lib/fatfs/mmc.c **** 					for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);
 436:./lib/fatfs/mmc.c **** 					ty = (ocr[0] & 0x40) ? CT_SD2|CT_BLOCK : CT_SD2;	/* SDv2 */
 437:./lib/fatfs/mmc.c **** 				}
 438:./lib/fatfs/mmc.c **** 			}
 439:./lib/fatfs/mmc.c **** 		} else {							/* SDv1 or MMCv3 */
 440:./lib/fatfs/mmc.c **** 			if (send_cmd(ACMD41, 0) <= 1) 	{
 441:./lib/fatfs/mmc.c **** 				ty = CT_SD1; cmd = ACMD41;	/* SDv1 */
 442:./lib/fatfs/mmc.c **** 			} else {
 443:./lib/fatfs/mmc.c **** 				ty = CT_MMC; cmd = CMD1;	/* MMCv3 */
 444:./lib/fatfs/mmc.c **** 			}
 445:./lib/fatfs/mmc.c **** 			while ((TimerGet() < timeOutTime) && send_cmd(cmd, 0));		/* Wait for leaving idle state */
 446:./lib/fatfs/mmc.c **** 			if (!(TimerGet() < timeOutTime) || send_cmd(CMD16, 512) != 0)	/* Set read/write block length to 
 447:./lib/fatfs/mmc.c **** 				ty = 0;
 448:./lib/fatfs/mmc.c **** 		}
 449:./lib/fatfs/mmc.c **** 	}
 450:./lib/fatfs/mmc.c **** 	CardType = ty;
 451:./lib/fatfs/mmc.c **** 	deselect();
 452:./lib/fatfs/mmc.c **** 
 453:./lib/fatfs/mmc.c **** 	if (ty) {			/* Initialization succeded */
 454:./lib/fatfs/mmc.c **** 		Stat &= ~STA_NOINIT;	/* Clear STA_NOINIT */
 455:./lib/fatfs/mmc.c **** 		FCLK_FAST();
 456:./lib/fatfs/mmc.c **** 	} else {			/* Initialization failed */
 457:./lib/fatfs/mmc.c **** 		power_off();
 458:./lib/fatfs/mmc.c **** 	}
 459:./lib/fatfs/mmc.c **** 
 460:./lib/fatfs/mmc.c **** 	return Stat;
 461:./lib/fatfs/mmc.c **** }
 531              		.loc 1 461 0 is_stmt 1 discriminator 1
 532 0016 7047     		bx	lr
 533              	.LVL74:
 534              	.L52:
 414:./lib/fatfs/mmc.c **** 	BYTE n, cmd, ty, ocr[4];
 535              		.loc 1 414 0
 536 0018 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 537              		.cfi_def_cfa_offset 28
 538              		.cfi_offset 4, -28
 539              		.cfi_offset 5, -24
 540              		.cfi_offset 6, -20
 541              		.cfi_offset 7, -16
 542              		.cfi_offset 8, -12
 543              		.cfi_offset 9, -8
 544              		.cfi_offset 14, -4
 545 001c 89B0     		sub	sp, sp, #36
 546              		.cfi_def_cfa_offset 64
 547              	.LBB18:
 548              	.LBB19:
 131:./lib/fatfs/mmc.c ****   /* Enable SPI clock, SPI2: APB1 */
 549              		.loc 1 131 0
 550 001e 0820     		movs	r0, #8
 551              	.LVL75:
 552 0020 0121     		movs	r1, #1
 553 0022 FFF7FEFF 		bl	RCC_APB2PeriphClockCmd
 554              	.LVL76:
 133:./lib/fatfs/mmc.c ****   /* Configure I/O for Flash Chip select (PB12) */
 555              		.loc 1 133 0
 556 0026 4FF48040 		mov	r0, #16384
 557 002a 0121     		movs	r1, #1
 558 002c FFF7FEFF 		bl	RCC_APB1PeriphClockCmd
 559              	.LVL77:
 135:./lib/fatfs/mmc.c ****   GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
 560              		.loc 1 135 0
 561 0030 4FF48057 		mov	r7, #4096
 562 0034 ADF80070 		strh	r7, [sp]	@ movhi
 136:./lib/fatfs/mmc.c ****   GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 563              		.loc 1 136 0
 564 0038 4FF01009 		mov	r9, #16
 565 003c 8DF80390 		strb	r9, [sp, #3]
 137:./lib/fatfs/mmc.c ****   GPIO_Init(GPIOB, &GPIO_InitStructure);
 566              		.loc 1 137 0
 567 0040 0326     		movs	r6, #3
 568 0042 8DF80260 		strb	r6, [sp, #2]
 138:./lib/fatfs/mmc.c **** 
 569              		.loc 1 138 0
 570 0046 A34C     		ldr	r4, .L84+4
 571 0048 2046     		mov	r0, r4
 572 004a 6946     		mov	r1, sp
 573 004c FFF7FEFF 		bl	GPIO_Init
 574              	.LVL78:
 141:./lib/fatfs/mmc.c **** 
 575              		.loc 1 141 0
 576 0050 2046     		mov	r0, r4
 577 0052 3946     		mov	r1, r7
 578 0054 FFF7FEFF 		bl	GPIO_SetBits
 579              	.LVL79:
 144:./lib/fatfs/mmc.c ****   GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 580              		.loc 1 144 0
 581 0058 4FF42043 		mov	r3, #40960
 582 005c ADF80030 		strh	r3, [sp]	@ movhi
 145:./lib/fatfs/mmc.c ****   GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF_PP;
 583              		.loc 1 145 0
 584 0060 8DF80260 		strb	r6, [sp, #2]
 146:./lib/fatfs/mmc.c ****   GPIO_Init(GPIOB, &GPIO_InitStructure);
 585              		.loc 1 146 0
 586 0064 1823     		movs	r3, #24
 587 0066 8DF80330 		strb	r3, [sp, #3]
 147:./lib/fatfs/mmc.c ****   /* Configure MISO (PB14) as Input with internal pull-up */
 588              		.loc 1 147 0
 589 006a 2046     		mov	r0, r4
 590 006c 6946     		mov	r1, sp
 591 006e FFF7FEFF 		bl	GPIO_Init
 592              	.LVL80:
 149:./lib/fatfs/mmc.c ****   GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPU;
 593              		.loc 1 149 0
 594 0072 4FF48043 		mov	r3, #16384
 595 0076 ADF80030 		strh	r3, [sp]	@ movhi
 150:./lib/fatfs/mmc.c ****   GPIO_Init(GPIOB, &GPIO_InitStructure);
 596              		.loc 1 150 0
 597 007a 4823     		movs	r3, #72
 598 007c 8DF80330 		strb	r3, [sp, #3]
 151:./lib/fatfs/mmc.c **** 
 599              		.loc 1 151 0
 600 0080 2046     		mov	r0, r4
 601 0082 6946     		mov	r1, sp
 602 0084 FFF7FEFF 		bl	GPIO_Init
 603              	.LVL81:
 154:./lib/fatfs/mmc.c ****   SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
 604              		.loc 1 154 0
 605 0088 0025     		movs	r5, #0
 606 008a ADF80850 		strh	r5, [sp, #8]	@ movhi
 155:./lib/fatfs/mmc.c ****   SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
 607              		.loc 1 155 0
 608 008e 4FF48273 		mov	r3, #260
 609 0092 ADF80A30 		strh	r3, [sp, #10]	@ movhi
 156:./lib/fatfs/mmc.c ****   SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
 610              		.loc 1 156 0
 611 0096 ADF80C50 		strh	r5, [sp, #12]	@ movhi
 157:./lib/fatfs/mmc.c ****   SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
 612              		.loc 1 157 0
 613 009a ADF80E50 		strh	r5, [sp, #14]	@ movhi
 158:./lib/fatfs/mmc.c ****   SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
 614              		.loc 1 158 0
 615 009e ADF81050 		strh	r5, [sp, #16]	@ movhi
 159:./lib/fatfs/mmc.c ****   SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_256; // 72000kHz/256=281kHz < 400
 616              		.loc 1 159 0
 617 00a2 4FF40073 		mov	r3, #512
 618 00a6 ADF81230 		strh	r3, [sp, #18]	@ movhi
 160:./lib/fatfs/mmc.c ****   SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
 619              		.loc 1 160 0
 620 00aa 3823     		movs	r3, #56
 621 00ac ADF81430 		strh	r3, [sp, #20]	@ movhi
 161:./lib/fatfs/mmc.c ****   SPI_InitStructure.SPI_CRCPolynomial = 7;
 622              		.loc 1 161 0
 623 00b0 ADF81650 		strh	r5, [sp, #22]	@ movhi
 162:./lib/fatfs/mmc.c **** 
 624              		.loc 1 162 0
 625 00b4 0723     		movs	r3, #7
 626 00b6 ADF81830 		strh	r3, [sp, #24]	@ movhi
 164:./lib/fatfs/mmc.c ****   SPI_CalculateCRC(SPI2, DISABLE);
 627              		.loc 1 164 0
 628 00ba DFF82082 		ldr	r8, .L84+12
 629 00be 4046     		mov	r0, r8
 630 00c0 02A9     		add	r1, sp, #8
 631 00c2 FFF7FEFF 		bl	SPI_Init
 632              	.LVL82:
 165:./lib/fatfs/mmc.c ****   SPI_Cmd(SPI2, ENABLE);
 633              		.loc 1 165 0
 634 00c6 4046     		mov	r0, r8
 635 00c8 2946     		mov	r1, r5
 636 00ca FFF7FEFF 		bl	SPI_CalculateCRC
 637              	.LVL83:
 166:./lib/fatfs/mmc.c **** 
 638              		.loc 1 166 0
 639 00ce 4046     		mov	r0, r8
 640 00d0 0121     		movs	r1, #1
 641 00d2 FFF7FEFF 		bl	SPI_Cmd
 642              	.LVL84:
 643              	.LBB20:
 644              	.LBB21:
  82:./lib/fatfs/mmc.c **** 
 645              		.loc 1 82 0
 646 00d6 2046     		mov	r0, r4
 647 00d8 3946     		mov	r1, r7
 648 00da FFF7FEFF 		bl	GPIO_SetBits
 649              	.LVL85:
  85:./lib/fatfs/mmc.c ****   GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 650              		.loc 1 85 0
 651 00de 4FF40045 		mov	r5, #32768
 652 00e2 ADF80450 		strh	r5, [sp, #4]	@ movhi
  86:./lib/fatfs/mmc.c ****   GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
 653              		.loc 1 86 0
 654 00e6 8DF80660 		strb	r6, [sp, #6]
  87:./lib/fatfs/mmc.c ****   GPIO_Init(GPIOB, &GPIO_InitStructure);
 655              		.loc 1 87 0
 656 00ea 8DF80790 		strb	r9, [sp, #7]
  88:./lib/fatfs/mmc.c ****   GPIO_SetBits(GPIOB, GPIO_Pin_15);
 657              		.loc 1 88 0
 658 00ee 2046     		mov	r0, r4
 659 00f0 01A9     		add	r1, sp, #4
 660 00f2 FFF7FEFF 		bl	GPIO_Init
 661              	.LVL86:
  89:./lib/fatfs/mmc.c **** 
 662              		.loc 1 89 0
 663 00f6 2046     		mov	r0, r4
 664 00f8 2946     		mov	r1, r5
 665 00fa FFF7FEFF 		bl	GPIO_SetBits
 666              	.LVL87:
 667 00fe 0A27     		movs	r7, #10
  96:./lib/fatfs/mmc.c **** 
 668              		.loc 1 96 0
 669 0100 0226     		movs	r6, #2
 670 0102 4446     		mov	r4, r8
 671              	.LVL88:
 672              	.L53:
 673 0104 2046     		mov	r0, r4
 674 0106 3146     		mov	r1, r6
 675 0108 FFF7FEFF 		bl	SPI_I2S_GetFlagStatus
 676              	.LVL89:
 677 010c 0028     		cmp	r0, #0
 678 010e F9D0     		beq	.L53
  99:./lib/fatfs/mmc.c **** 
 679              		.loc 1 99 0
 680 0110 2046     		mov	r0, r4
 681 0112 FF21     		movs	r1, #255
 682 0114 FFF7FEFF 		bl	SPI_I2S_SendData
 683              	.LVL90:
 102:./lib/fatfs/mmc.c ****   }
 684              		.loc 1 102 0
 685 0118 0125     		movs	r5, #1
 686              	.L54:
 687 011a 2046     		mov	r0, r4
 688 011c 2946     		mov	r1, r5
 689 011e FFF7FEFF 		bl	SPI_I2S_GetFlagStatus
 690              	.LVL91:
 691 0122 0028     		cmp	r0, #0
 692 0124 F9D0     		beq	.L54
 693              	.LVL92:
  93:./lib/fatfs/mmc.c ****   {
 694              		.loc 1 93 0
 695 0126 013F     		subs	r7, r7, #1
 696              	.LVL93:
 697 0128 ECD1     		bne	.L53
 106:./lib/fatfs/mmc.c ****   GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 698              		.loc 1 106 0
 699 012a 4FF40043 		mov	r3, #32768
 700 012e ADF80430 		strh	r3, [sp, #4]	@ movhi
 107:./lib/fatfs/mmc.c ****   GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF_PP;
 701              		.loc 1 107 0
 702 0132 0323     		movs	r3, #3
 703 0134 8DF80630 		strb	r3, [sp, #6]
 108:./lib/fatfs/mmc.c ****   GPIO_Init(GPIOB, &GPIO_InitStructure);
 704              		.loc 1 108 0
 705 0138 1823     		movs	r3, #24
 706 013a 8DF80730 		strb	r3, [sp, #7]
 109:./lib/fatfs/mmc.c **** }
 707              		.loc 1 109 0
 708 013e 654C     		ldr	r4, .L84+4
 709 0140 2046     		mov	r0, r4
 710 0142 01A9     		add	r1, sp, #4
 711 0144 FFF7FEFF 		bl	GPIO_Init
 712              	.LVL94:
 713              	.LBE21:
 714              	.LBE20:
 715              	.LBE19:
 716              	.LBE18:
 424:./lib/fatfs/mmc.c **** 
 717              		.loc 1 424 0
 718 0148 2046     		mov	r0, r4
 719 014a 4FF48051 		mov	r1, #4096
 720 014e FFF7FEFF 		bl	GPIO_ResetBits
 721              	.LVL95:
 427:./lib/fatfs/mmc.c ****     timeOutTime = TimerGet() + 1000; /* Initialization timeout of 1000 msec */
 722              		.loc 1 427 0
 723 0152 0020     		movs	r0, #0
 724 0154 0146     		mov	r1, r0
 725 0156 FFF7FEFF 		bl	send_cmd
 726              	.LVL96:
 727 015a 0128     		cmp	r0, #1
 728 015c 40F0AF80 		bne	.L56
 428:./lib/fatfs/mmc.c **** 
 729              		.loc 1 428 0
 730 0160 FFF7FEFF 		bl	TimerGet
 731              	.LVL97:
 732 0164 00F57A74 		add	r4, r0, #1000
 733              	.LVL98:
 430:./lib/fatfs/mmc.c **** 			for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);			/* Get trailing return value of R7 resp */
 734              		.loc 1 430 0
 735 0168 0820     		movs	r0, #8
 736 016a 4FF4D571 		mov	r1, #426
 737 016e FFF7FEFF 		bl	send_cmd
 738              	.LVL99:
 739 0172 0128     		cmp	r0, #1
 740 0174 43D1     		bne	.L57
 741 0176 07AE     		add	r6, sp, #28
 742 0178 08AF     		add	r7, sp, #32
 743              	.LVL100:
 744 017a 3546     		mov	r5, r6
 431:./lib/fatfs/mmc.c **** 			if (ocr[2] == 0x01 && ocr[3] == 0xAA) {				/* The card can work at vdd range of 2.7-3.6V */
 745              		.loc 1 431 0
 746 017c 4FF0FF08 		mov	r8, #255
 747              	.L58:
 748              	.LVL101:
 431:./lib/fatfs/mmc.c **** 			if (ocr[2] == 0x01 && ocr[3] == 0xAA) {				/* The card can work at vdd range of 2.7-3.6V */
 749              		.loc 1 431 0 is_stmt 0 discriminator 3
 750 0180 4046     		mov	r0, r8
 751 0182 FFF7FEFF 		bl	xchg_spi
 752              	.LVL102:
 753 0186 05F8010B 		strb	r0, [r5], #1
 754              	.LVL103:
 755 018a BD42     		cmp	r5, r7
 756 018c F8D1     		bne	.L58
 432:./lib/fatfs/mmc.c **** 				while ((TimerGet() < timeOutTime) && send_cmd(ACMD41, 0x40000000));	/* Wait for leaving idle st
 757              		.loc 1 432 0 is_stmt 1
 758 018e 9DF81E30 		ldrb	r3, [sp, #30]	@ zero_extendqisi2
 759 0192 012B     		cmp	r3, #1
 760 0194 40F09380 		bne	.L56
 432:./lib/fatfs/mmc.c **** 				while ((TimerGet() < timeOutTime) && send_cmd(ACMD41, 0x40000000));	/* Wait for leaving idle st
 761              		.loc 1 432 0 is_stmt 0 discriminator 1
 762 0198 9DF81F30 		ldrb	r3, [sp, #31]	@ zero_extendqisi2
 763 019c AA2B     		cmp	r3, #170
 764 019e 40F08E80 		bne	.L56
 433:./lib/fatfs/mmc.c **** 				if ((TimerGet() < timeOutTime) && send_cmd(CMD58, 0) == 0) {			/* Check CCS bit in the OCR */
 765              		.loc 1 433 0 is_stmt 1 discriminator 2
 766 01a2 4FF0A908 		mov	r8, #169
 767 01a6 4FF08045 		mov	r5, #1073741824
 768              	.LVL104:
 769              	.L73:
 770 01aa FFF7FEFF 		bl	TimerGet
 771              	.LVL105:
 772 01ae 8442     		cmp	r4, r0
 773 01b0 05D9     		bls	.L59
 433:./lib/fatfs/mmc.c **** 				if ((TimerGet() < timeOutTime) && send_cmd(CMD58, 0) == 0) {			/* Check CCS bit in the OCR */
 774              		.loc 1 433 0 is_stmt 0 discriminator 1
 775 01b2 4046     		mov	r0, r8
 776 01b4 2946     		mov	r1, r5
 777 01b6 FFF7FEFF 		bl	send_cmd
 778              	.LVL106:
 779 01ba 0028     		cmp	r0, #0
 780 01bc F5D1     		bne	.L73
 781              	.L59:
 434:./lib/fatfs/mmc.c **** 					for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);
 782              		.loc 1 434 0 is_stmt 1
 783 01be FFF7FEFF 		bl	TimerGet
 784              	.LVL107:
 785 01c2 8442     		cmp	r4, r0
 786 01c4 7BD9     		bls	.L56
 434:./lib/fatfs/mmc.c **** 					for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);
 787              		.loc 1 434 0 is_stmt 0 discriminator 1
 788 01c6 3A20     		movs	r0, #58
 789 01c8 0021     		movs	r1, #0
 790 01ca FFF7FEFF 		bl	send_cmd
 791              	.LVL108:
 792 01ce 0028     		cmp	r0, #0
 793 01d0 75D1     		bne	.L56
 435:./lib/fatfs/mmc.c **** 					ty = (ocr[0] & 0x40) ? CT_SD2|CT_BLOCK : CT_SD2;	/* SDv2 */
 794              		.loc 1 435 0 is_stmt 1 discriminator 3
 795 01d2 FF24     		movs	r4, #255
 796              	.LVL109:
 797              	.L72:
 798 01d4 2046     		mov	r0, r4
 799 01d6 FFF7FEFF 		bl	xchg_spi
 800              	.LVL110:
 801 01da 06F8010B 		strb	r0, [r6], #1
 802              	.LVL111:
 803 01de BE42     		cmp	r6, r7
 804 01e0 F8D1     		bne	.L72
 436:./lib/fatfs/mmc.c **** 				}
 805              		.loc 1 436 0
 806 01e2 9DF81C30 		ldrb	r3, [sp, #28]	@ zero_extendqisi2
 807 01e6 03F04003 		and	r3, r3, #64
 808 01ea DBB2     		uxtb	r3, r3
 809 01ec 002B     		cmp	r3, #0
 810 01ee 14BF     		ite	ne
 811 01f0 0C22     		movne	r2, #12
 812 01f2 0422     		moveq	r2, #4
 813              	.LVL112:
 450:./lib/fatfs/mmc.c **** 	deselect();
 814              		.loc 1 450 0
 815 01f4 384B     		ldr	r3, .L84+8
 816 01f6 1A60     		str	r2, [r3]
 451:./lib/fatfs/mmc.c **** 
 817              		.loc 1 451 0
 818 01f8 FFF7FEFF 		bl	deselect
 819              	.LVL113:
 820 01fc 24E0     		b	.L68
 821              	.LVL114:
 822              	.L57:
 440:./lib/fatfs/mmc.c **** 				ty = CT_SD1; cmd = ACMD41;	/* SDv1 */
 823              		.loc 1 440 0
 824 01fe A920     		movs	r0, #169
 825 0200 0021     		movs	r1, #0
 826 0202 FFF7FEFF 		bl	send_cmd
 827              	.LVL115:
 828 0206 0128     		cmp	r0, #1
 443:./lib/fatfs/mmc.c **** 			}
 829              		.loc 1 443 0
 830 0208 87BF     		ittee	hi
 831 020a 0127     		movhi	r7, #1
 832              	.LVL116:
 833 020c 3D46     		movhi	r5, r7
 441:./lib/fatfs/mmc.c **** 			} else {
 834              		.loc 1 441 0
 835 020e 0227     		movls	r7, #2
 836 0210 A925     		movls	r5, #169
 445:./lib/fatfs/mmc.c **** 			if (!(TimerGet() < timeOutTime) || send_cmd(CMD16, 512) != 0)	/* Set read/write block length to 
 837              		.loc 1 445 0
 838 0212 0026     		movs	r6, #0
 839              	.LVL117:
 840              	.L65:
 445:./lib/fatfs/mmc.c **** 			if (!(TimerGet() < timeOutTime) || send_cmd(CMD16, 512) != 0)	/* Set read/write block length to 
 841              		.loc 1 445 0 is_stmt 0 discriminator 2
 842 0214 FFF7FEFF 		bl	TimerGet
 843              	.LVL118:
 844 0218 8442     		cmp	r4, r0
 845 021a 05D9     		bls	.L64
 445:./lib/fatfs/mmc.c **** 			if (!(TimerGet() < timeOutTime) || send_cmd(CMD16, 512) != 0)	/* Set read/write block length to 
 846              		.loc 1 445 0 discriminator 1
 847 021c 2846     		mov	r0, r5
 848 021e 3146     		mov	r1, r6
 849 0220 FFF7FEFF 		bl	send_cmd
 850              	.LVL119:
 851 0224 0028     		cmp	r0, #0
 852 0226 F5D1     		bne	.L65
 853              	.L64:
 446:./lib/fatfs/mmc.c **** 				ty = 0;
 854              		.loc 1 446 0 is_stmt 1
 855 0228 FFF7FEFF 		bl	TimerGet
 856              	.LVL120:
 857 022c 8442     		cmp	r4, r0
 858 022e 46D9     		bls	.L56
 446:./lib/fatfs/mmc.c **** 				ty = 0;
 859              		.loc 1 446 0 is_stmt 0 discriminator 1
 860 0230 1020     		movs	r0, #16
 861 0232 4FF40071 		mov	r1, #512
 862 0236 FFF7FEFF 		bl	send_cmd
 863              	.LVL121:
 864 023a 0028     		cmp	r0, #0
 865 023c 3FD1     		bne	.L56
 866              	.LVL122:
 450:./lib/fatfs/mmc.c **** 	deselect();
 867              		.loc 1 450 0 is_stmt 1
 868 023e 264B     		ldr	r3, .L84+8
 869 0240 1F60     		str	r7, [r3]
 451:./lib/fatfs/mmc.c **** 
 870              		.loc 1 451 0
 871 0242 FFF7FEFF 		bl	deselect
 872              	.LVL123:
 453:./lib/fatfs/mmc.c **** 		Stat &= ~STA_NOINIT;	/* Clear STA_NOINIT */
 873              		.loc 1 453 0
 874 0246 7FB3     		cbz	r7, .L66
 875              	.LVL124:
 876              	.L68:
 454:./lib/fatfs/mmc.c **** 		FCLK_FAST();
 877              		.loc 1 454 0
 878 0248 214A     		ldr	r2, .L84
 879 024a 1378     		ldrb	r3, [r2]	@ zero_extendqisi2
 880 024c 03F0FE03 		and	r3, r3, #254
 881 0250 1370     		strb	r3, [r2]
 882              	.LBB22:
 883              	.LBB23:
 180:./lib/fatfs/mmc.c **** 
 884              		.loc 1 180 0
 885 0252 224D     		ldr	r5, .L84+12
 886 0254 2846     		mov	r0, r5
 887 0256 0021     		movs	r1, #0
 888 0258 FFF7FEFF 		bl	SPI_Cmd
 889              	.LVL125:
 185:./lib/fatfs/mmc.c ****   SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
 890              		.loc 1 185 0
 891 025c 0024     		movs	r4, #0
 892 025e ADF80840 		strh	r4, [sp, #8]	@ movhi
 186:./lib/fatfs/mmc.c ****   SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
 893              		.loc 1 186 0
 894 0262 4FF48273 		mov	r3, #260
 895 0266 ADF80A30 		strh	r3, [sp, #10]	@ movhi
 187:./lib/fatfs/mmc.c ****   SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
 896              		.loc 1 187 0
 897 026a ADF80C40 		strh	r4, [sp, #12]	@ movhi
 188:./lib/fatfs/mmc.c ****   SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
 898              		.loc 1 188 0
 899 026e ADF80E40 		strh	r4, [sp, #14]	@ movhi
 189:./lib/fatfs/mmc.c ****   SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
 900              		.loc 1 189 0
 901 0272 ADF81040 		strh	r4, [sp, #16]	@ movhi
 190:./lib/fatfs/mmc.c ****   SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_4; // 72MHz/4=18MHz < 20MHz
 902              		.loc 1 190 0
 903 0276 4FF40073 		mov	r3, #512
 904 027a ADF81230 		strh	r3, [sp, #18]	@ movhi
 191:./lib/fatfs/mmc.c ****   SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
 905              		.loc 1 191 0
 906 027e 0823     		movs	r3, #8
 907 0280 ADF81430 		strh	r3, [sp, #20]	@ movhi
 192:./lib/fatfs/mmc.c ****   SPI_InitStructure.SPI_CRCPolynomial = 7;
 908              		.loc 1 192 0
 909 0284 ADF81640 		strh	r4, [sp, #22]	@ movhi
 193:./lib/fatfs/mmc.c ****   SPI_Init(SPI2, &SPI_InitStructure);
 910              		.loc 1 193 0
 911 0288 0723     		movs	r3, #7
 912 028a ADF81830 		strh	r3, [sp, #24]	@ movhi
 194:./lib/fatfs/mmc.c ****   SPI_CalculateCRC(SPI2, DISABLE);
 913              		.loc 1 194 0
 914 028e 2846     		mov	r0, r5
 915 0290 02A9     		add	r1, sp, #8
 916 0292 FFF7FEFF 		bl	SPI_Init
 917              	.LVL126:
 195:./lib/fatfs/mmc.c **** 
 918              		.loc 1 195 0
 919 0296 2846     		mov	r0, r5
 920 0298 2146     		mov	r1, r4
 921 029a FFF7FEFF 		bl	SPI_CalculateCRC
 922              	.LVL127:
 198:./lib/fatfs/mmc.c **** }
 923              		.loc 1 198 0
 924 029e 2846     		mov	r0, r5
 925 02a0 0121     		movs	r1, #1
 926 02a2 FFF7FEFF 		bl	SPI_Cmd
 927              	.LVL128:
 928 02a6 04E0     		b	.L67
 929              	.L66:
 930              	.LVL129:
 931              	.LBE23:
 932              	.LBE22:
 933              	.LBB24:
 934              	.LBB25:
 204:./lib/fatfs/mmc.c **** }
 935              		.loc 1 204 0
 936 02a8 094A     		ldr	r2, .L84
 937 02aa 1378     		ldrb	r3, [r2]	@ zero_extendqisi2
 938 02ac 43F00103 		orr	r3, r3, #1
 939 02b0 1370     		strb	r3, [r2]
 940              	.LVL130:
 941              	.L67:
 942              	.LBE25:
 943              	.LBE24:
 460:./lib/fatfs/mmc.c **** }
 944              		.loc 1 460 0
 945 02b2 074B     		ldr	r3, .L84
 946 02b4 1878     		ldrb	r0, [r3]	@ zero_extendqisi2
 947 02b6 C0B2     		uxtb	r0, r0
 948 02b8 07E0     		b	.L81
 949              	.LVL131:
 950              	.L69:
 951              		.cfi_def_cfa_offset 0
 952              		.cfi_restore 4
 953              		.cfi_restore 5
 954              		.cfi_restore 6
 955              		.cfi_restore 7
 956              		.cfi_restore 8
 957              		.cfi_restore 9
 958              		.cfi_restore 14
 419:./lib/fatfs/mmc.c **** 	if (Stat & STA_NODISK) return Stat;	/* No card in the socket */
 959              		.loc 1 419 0
 960 02ba 0120     		movs	r0, #1
 961              	.LVL132:
 962 02bc 7047     		bx	lr
 963              	.L56:
 964              		.cfi_def_cfa_offset 64
 965              		.cfi_offset 4, -28
 966              		.cfi_offset 5, -24
 967              		.cfi_offset 6, -20
 968              		.cfi_offset 7, -16
 969              		.cfi_offset 8, -12
 970              		.cfi_offset 9, -8
 971              		.cfi_offset 14, -4
 972              	.LVL133:
 450:./lib/fatfs/mmc.c **** 	deselect();
 973              		.loc 1 450 0
 974 02be 0022     		movs	r2, #0
 975 02c0 054B     		ldr	r3, .L84+8
 976 02c2 1A60     		str	r2, [r3]
 451:./lib/fatfs/mmc.c **** 
 977              		.loc 1 451 0
 978 02c4 FFF7FEFF 		bl	deselect
 979              	.LVL134:
 980 02c8 EEE7     		b	.L66
 981              	.LVL135:
 982              	.L81:
 983              		.loc 1 461 0
 984 02ca 09B0     		add	sp, sp, #36
 985              		.cfi_def_cfa_offset 28
 986              		@ sp needed
 987 02cc BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 988              	.L85:
 989              		.align	2
 990              	.L84:
 991 02d0 00000000 		.word	.LANCHOR0
 992 02d4 000C0140 		.word	1073810432
 993 02d8 00000000 		.word	.LANCHOR1
 994 02dc 00380040 		.word	1073756160
 995              		.cfi_endproc
 996              	.LFE41:
 998              		.section	.text.disk_status,"ax",%progbits
 999              		.align	2
 1000              		.global	disk_status
 1001              		.thumb
 1002              		.thumb_func
 1004              	disk_status:
 1005              	.LFB42:
 462:./lib/fatfs/mmc.c **** 
 463:./lib/fatfs/mmc.c **** 
 464:./lib/fatfs/mmc.c **** 
 465:./lib/fatfs/mmc.c **** /*-----------------------------------------------------------------------*/
 466:./lib/fatfs/mmc.c **** /* Get Disk Status                                                       */
 467:./lib/fatfs/mmc.c **** /*-----------------------------------------------------------------------*/
 468:./lib/fatfs/mmc.c **** 
 469:./lib/fatfs/mmc.c **** DSTATUS disk_status (
 470:./lib/fatfs/mmc.c **** 	BYTE pdrv		/* Physical drive nmuber (0) */
 471:./lib/fatfs/mmc.c **** )
 472:./lib/fatfs/mmc.c **** {
 1006              		.loc 1 472 0
 1007              		.cfi_startproc
 1008              		@ args = 0, pretend = 0, frame = 0
 1009              		@ frame_needed = 0, uses_anonymous_args = 0
 1010              		@ link register save eliminated.
 1011              	.LVL136:
 473:./lib/fatfs/mmc.c **** 	if (pdrv) return STA_NOINIT;	/* Supports only single drive */
 1012              		.loc 1 473 0
 1013 0000 18B9     		cbnz	r0, .L88
 474:./lib/fatfs/mmc.c **** 	return Stat;
 1014              		.loc 1 474 0
 1015 0002 034B     		ldr	r3, .L89
 1016 0004 1878     		ldrb	r0, [r3]	@ zero_extendqisi2
 1017              	.LVL137:
 1018 0006 C0B2     		uxtb	r0, r0
 1019 0008 7047     		bx	lr
 1020              	.LVL138:
 1021              	.L88:
 473:./lib/fatfs/mmc.c **** 	if (pdrv) return STA_NOINIT;	/* Supports only single drive */
 1022              		.loc 1 473 0
 1023 000a 0120     		movs	r0, #1
 1024              	.LVL139:
 475:./lib/fatfs/mmc.c **** }
 1025              		.loc 1 475 0
 1026 000c 7047     		bx	lr
 1027              	.L90:
 1028 000e 00BF     		.align	2
 1029              	.L89:
 1030 0010 00000000 		.word	.LANCHOR0
 1031              		.cfi_endproc
 1032              	.LFE42:
 1034              		.section	.text.disk_read,"ax",%progbits
 1035              		.align	2
 1036              		.global	disk_read
 1037              		.thumb
 1038              		.thumb_func
 1040              	disk_read:
 1041              	.LFB43:
 476:./lib/fatfs/mmc.c **** 
 477:./lib/fatfs/mmc.c **** 
 478:./lib/fatfs/mmc.c **** 
 479:./lib/fatfs/mmc.c **** /*-----------------------------------------------------------------------*/
 480:./lib/fatfs/mmc.c **** /* Read Sector(s)                                                        */
 481:./lib/fatfs/mmc.c **** /*-----------------------------------------------------------------------*/
 482:./lib/fatfs/mmc.c **** 
 483:./lib/fatfs/mmc.c **** DRESULT disk_read (
 484:./lib/fatfs/mmc.c **** 	BYTE pdrv,		/* Physical drive number (0) */
 485:./lib/fatfs/mmc.c **** 	BYTE *buff,		/* Pointer to the data buffer to store read data */
 486:./lib/fatfs/mmc.c **** 	DWORD sector,	/* Start sector number (LBA) */
 487:./lib/fatfs/mmc.c **** 	BYTE count		/* Sector count (1..255) */
 488:./lib/fatfs/mmc.c **** )
 489:./lib/fatfs/mmc.c **** {
 1042              		.loc 1 489 0
 1043              		.cfi_startproc
 1044              		@ args = 0, pretend = 0, frame = 0
 1045              		@ frame_needed = 0, uses_anonymous_args = 0
 1046              	.LVL140:
 490:./lib/fatfs/mmc.c **** 	if (pdrv || !count) return RES_PARERR;
 1047              		.loc 1 490 0
 1048 0000 0028     		cmp	r0, #0
 1049 0002 3BD1     		bne	.L98
 489:./lib/fatfs/mmc.c **** 	if (pdrv || !count) return RES_PARERR;
 1050              		.loc 1 489 0 discriminator 2
 1051 0004 70B5     		push	{r4, r5, r6, lr}
 1052              		.cfi_def_cfa_offset 16
 1053              		.cfi_offset 4, -16
 1054              		.cfi_offset 5, -12
 1055              		.cfi_offset 6, -8
 1056              		.cfi_offset 14, -4
 1057 0006 0D46     		mov	r5, r1
 1058 0008 1C46     		mov	r4, r3
 1059              		.loc 1 490 0 discriminator 2
 1060 000a 002B     		cmp	r3, #0
 1061 000c 38D0     		beq	.L99
 491:./lib/fatfs/mmc.c **** 	if (Stat & STA_NOINIT) return RES_NOTRDY;
 1062              		.loc 1 491 0
 1063 000e 1E4B     		ldr	r3, .L104
 1064              	.LVL141:
 1065 0010 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1066 0012 13F0010F 		tst	r3, #1
 1067 0016 35D1     		bne	.L100
 492:./lib/fatfs/mmc.c **** 
 493:./lib/fatfs/mmc.c **** 	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */
 1068              		.loc 1 493 0
 1069 0018 1C4B     		ldr	r3, .L104+4
 1070 001a 1B68     		ldr	r3, [r3]
 1071 001c 13F0080F 		tst	r3, #8
 1072 0020 08BF     		it	eq
 1073 0022 5202     		lsleq	r2, r2, #9
 1074              	.LVL142:
 494:./lib/fatfs/mmc.c **** 
 495:./lib/fatfs/mmc.c **** 	if (count == 1) {		/* Single block read */
 1075              		.loc 1 495 0
 1076 0024 012C     		cmp	r4, #1
 1077 0026 0DD1     		bne	.L94
 496:./lib/fatfs/mmc.c **** 		if ((send_cmd(CMD17, sector) == 0)	/* READ_SINGLE_BLOCK */
 1078              		.loc 1 496 0
 1079 0028 1120     		movs	r0, #17
 1080              	.LVL143:
 1081 002a 1146     		mov	r1, r2
 1082              	.LVL144:
 1083 002c FFF7FEFF 		bl	send_cmd
 1084              	.LVL145:
 1085 0030 F0B9     		cbnz	r0, .L95
 497:./lib/fatfs/mmc.c **** 			&& rcvr_datablock(buff, 512))
 1086              		.loc 1 497 0
 1087 0032 2846     		mov	r0, r5
 1088 0034 4FF40071 		mov	r1, #512
 1089 0038 FFF7FEFF 		bl	rcvr_datablock
 1090              	.LVL146:
 1091 003c B0FA80F4 		clz	r4, r0
 1092 0040 6409     		lsrs	r4, r4, #5
 1093 0042 15E0     		b	.L95
 1094              	.LVL147:
 1095              	.L94:
 498:./lib/fatfs/mmc.c **** 			count = 0;
 499:./lib/fatfs/mmc.c **** 	}
 500:./lib/fatfs/mmc.c **** 	else {				/* Multiple block read */
 501:./lib/fatfs/mmc.c **** 		if (send_cmd(CMD18, sector) == 0) {	/* READ_MULTIPLE_BLOCK */
 1096              		.loc 1 501 0
 1097 0044 1220     		movs	r0, #18
 1098              	.LVL148:
 1099 0046 1146     		mov	r1, r2
 1100              	.LVL149:
 1101 0048 FFF7FEFF 		bl	send_cmd
 1102              	.LVL150:
 1103 004c 80B9     		cbnz	r0, .L95
 502:./lib/fatfs/mmc.c **** 			do {
 503:./lib/fatfs/mmc.c **** 				if (!rcvr_datablock(buff, 512)) break;
 1104              		.loc 1 503 0
 1105 004e 4FF40076 		mov	r6, #512
 1106              	.LVL151:
 1107              	.L101:
 1108 0052 2846     		mov	r0, r5
 1109 0054 3146     		mov	r1, r6
 1110 0056 FFF7FEFF 		bl	rcvr_datablock
 1111              	.LVL152:
 1112 005a 28B1     		cbz	r0, .L96
 504:./lib/fatfs/mmc.c **** 				buff += 512;
 1113              		.loc 1 504 0
 1114 005c 05F50075 		add	r5, r5, #512
 1115              	.LVL153:
 505:./lib/fatfs/mmc.c **** 			} while (--count);
 1116              		.loc 1 505 0
 1117 0060 601E     		subs	r0, r4, #1
 1118              	.LVL154:
 1119 0062 10F0FF04 		ands	r4, r0, #255
 1120 0066 F4D1     		bne	.L101
 1121              	.LVL155:
 1122              	.L96:
 506:./lib/fatfs/mmc.c **** 			send_cmd(CMD12, 0);				/* STOP_TRANSMISSION */
 1123              		.loc 1 506 0
 1124 0068 0C20     		movs	r0, #12
 1125 006a 0021     		movs	r1, #0
 1126 006c FFF7FEFF 		bl	send_cmd
 1127              	.LVL156:
 1128              	.L95:
 507:./lib/fatfs/mmc.c **** 		}
 508:./lib/fatfs/mmc.c **** 	}
 509:./lib/fatfs/mmc.c **** 	deselect();
 1129              		.loc 1 509 0
 1130 0070 FFF7FEFF 		bl	deselect
 1131              	.LVL157:
 510:./lib/fatfs/mmc.c **** 
 511:./lib/fatfs/mmc.c **** 	return count ? RES_ERROR : RES_OK;
 1132              		.loc 1 511 0
 1133 0074 201C     		adds	r0, r4, #0
 1134 0076 18BF     		it	ne
 1135 0078 0120     		movne	r0, #1
 1136 007a 70BD     		pop	{r4, r5, r6, pc}
 1137              	.LVL158:
 1138              	.L98:
 1139              		.cfi_def_cfa_offset 0
 1140              		.cfi_restore 4
 1141              		.cfi_restore 5
 1142              		.cfi_restore 6
 1143              		.cfi_restore 14
 490:./lib/fatfs/mmc.c **** 	if (Stat & STA_NOINIT) return RES_NOTRDY;
 1144              		.loc 1 490 0
 1145 007c 0420     		movs	r0, #4
 1146              	.LVL159:
 512:./lib/fatfs/mmc.c **** }
 1147              		.loc 1 512 0
 1148 007e 7047     		bx	lr
 1149              	.LVL160:
 1150              	.L99:
 1151              		.cfi_def_cfa_offset 16
 1152              		.cfi_offset 4, -16
 1153              		.cfi_offset 5, -12
 1154              		.cfi_offset 6, -8
 1155              		.cfi_offset 14, -4
 490:./lib/fatfs/mmc.c **** 	if (Stat & STA_NOINIT) return RES_NOTRDY;
 1156              		.loc 1 490 0
 1157 0080 0420     		movs	r0, #4
 1158              	.LVL161:
 1159 0082 70BD     		pop	{r4, r5, r6, pc}
 1160              	.LVL162:
 1161              	.L100:
 491:./lib/fatfs/mmc.c **** 
 1162              		.loc 1 491 0
 1163 0084 0320     		movs	r0, #3
 1164              	.LVL163:
 1165              		.loc 1 512 0
 1166 0086 70BD     		pop	{r4, r5, r6, pc}
 1167              	.L105:
 1168              		.align	2
 1169              	.L104:
 1170 0088 00000000 		.word	.LANCHOR0
 1171 008c 00000000 		.word	.LANCHOR1
 1172              		.cfi_endproc
 1173              	.LFE43:
 1175              		.section	.text.disk_write,"ax",%progbits
 1176              		.align	2
 1177              		.global	disk_write
 1178              		.thumb
 1179              		.thumb_func
 1181              	disk_write:
 1182              	.LFB44:
 513:./lib/fatfs/mmc.c **** 
 514:./lib/fatfs/mmc.c **** 
 515:./lib/fatfs/mmc.c **** 
 516:./lib/fatfs/mmc.c **** /*-----------------------------------------------------------------------*/
 517:./lib/fatfs/mmc.c **** /* Write Sector(s)                                                       */
 518:./lib/fatfs/mmc.c **** /*-----------------------------------------------------------------------*/
 519:./lib/fatfs/mmc.c **** 
 520:./lib/fatfs/mmc.c **** #if _USE_WRITE
 521:./lib/fatfs/mmc.c **** DRESULT disk_write (
 522:./lib/fatfs/mmc.c **** 	BYTE pdrv,				/* Physical drive nmuber (0) */
 523:./lib/fatfs/mmc.c **** 	const BYTE *buff,		/* Pointer to the data to be written */
 524:./lib/fatfs/mmc.c **** 	DWORD sector,			/* Start sector number (LBA) */
 525:./lib/fatfs/mmc.c **** 	BYTE count				/* Sector count (1..255) */
 526:./lib/fatfs/mmc.c **** )
 527:./lib/fatfs/mmc.c **** {
 1183              		.loc 1 527 0
 1184              		.cfi_startproc
 1185              		@ args = 0, pretend = 0, frame = 0
 1186              		@ frame_needed = 0, uses_anonymous_args = 0
 1187              	.LVL164:
 528:./lib/fatfs/mmc.c **** 	if (pdrv || !count) return RES_PARERR;
 1188              		.loc 1 528 0
 1189 0000 0028     		cmp	r0, #0
 1190 0002 49D1     		bne	.L114
 527:./lib/fatfs/mmc.c **** 	if (pdrv || !count) return RES_PARERR;
 1191              		.loc 1 527 0 discriminator 2
 1192 0004 70B5     		push	{r4, r5, r6, lr}
 1193              		.cfi_def_cfa_offset 16
 1194              		.cfi_offset 4, -16
 1195              		.cfi_offset 5, -12
 1196              		.cfi_offset 6, -8
 1197              		.cfi_offset 14, -4
 1198 0006 0E46     		mov	r6, r1
 1199 0008 1546     		mov	r5, r2
 1200 000a 1C46     		mov	r4, r3
 1201              		.loc 1 528 0 discriminator 2
 1202 000c 002B     		cmp	r3, #0
 1203 000e 45D0     		beq	.L115
 529:./lib/fatfs/mmc.c **** 	if (Stat & STA_NOINIT) return RES_NOTRDY;
 1204              		.loc 1 529 0
 1205 0010 254B     		ldr	r3, .L121
 1206              	.LVL165:
 1207 0012 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1208 0014 13F0010F 		tst	r3, #1
 1209 0018 42D1     		bne	.L116
 530:./lib/fatfs/mmc.c **** 	if (Stat & STA_PROTECT) return RES_WRPRT;
 1210              		.loc 1 530 0
 1211 001a 234B     		ldr	r3, .L121
 1212 001c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1213 001e 13F0040F 		tst	r3, #4
 1214 0022 3FD1     		bne	.L117
 531:./lib/fatfs/mmc.c **** 
 532:./lib/fatfs/mmc.c **** 	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */
 1215              		.loc 1 532 0
 1216 0024 214B     		ldr	r3, .L121+4
 1217 0026 1B68     		ldr	r3, [r3]
 1218 0028 13F0080F 		tst	r3, #8
 1219 002c 08BF     		it	eq
 1220 002e 5502     		lsleq	r5, r2, #9
 1221              	.LVL166:
 533:./lib/fatfs/mmc.c **** 
 534:./lib/fatfs/mmc.c **** 	if (count == 1) {		/* Single block write */
 1222              		.loc 1 534 0
 1223 0030 012C     		cmp	r4, #1
 1224 0032 0CD1     		bne	.L109
 535:./lib/fatfs/mmc.c **** 		if ((send_cmd(CMD24, sector) == 0)	/* WRITE_BLOCK */
 1225              		.loc 1 535 0
 1226 0034 1820     		movs	r0, #24
 1227              	.LVL167:
 1228 0036 2946     		mov	r1, r5
 1229              	.LVL168:
 1230 0038 FFF7FEFF 		bl	send_cmd
 1231              	.LVL169:
 1232 003c 30BB     		cbnz	r0, .L110
 536:./lib/fatfs/mmc.c **** 			&& xmit_datablock(buff, 0xFE))
 1233              		.loc 1 536 0
 1234 003e 3046     		mov	r0, r6
 1235 0040 FE21     		movs	r1, #254
 1236 0042 FFF7FEFF 		bl	xmit_datablock
 1237              	.LVL170:
 1238 0046 B0FA80F4 		clz	r4, r0
 1239 004a 6409     		lsrs	r4, r4, #5
 1240 004c 1EE0     		b	.L110
 1241              	.LVL171:
 1242              	.L109:
 537:./lib/fatfs/mmc.c **** 			count = 0;
 538:./lib/fatfs/mmc.c **** 	}
 539:./lib/fatfs/mmc.c **** 	else {				/* Multiple block write */
 540:./lib/fatfs/mmc.c **** 		if (CardType & CT_SDC) send_cmd(ACMD23, count);
 1243              		.loc 1 540 0
 1244 004e 13F0060F 		tst	r3, #6
 1245 0052 03D0     		beq	.L111
 1246              		.loc 1 540 0 is_stmt 0 discriminator 1
 1247 0054 9720     		movs	r0, #151
 1248              	.LVL172:
 1249 0056 2146     		mov	r1, r4
 1250              	.LVL173:
 1251 0058 FFF7FEFF 		bl	send_cmd
 1252              	.LVL174:
 1253              	.L111:
 541:./lib/fatfs/mmc.c **** 		if (send_cmd(CMD25, sector) == 0) {	/* WRITE_MULTIPLE_BLOCK */
 1254              		.loc 1 541 0 is_stmt 1
 1255 005c 1920     		movs	r0, #25
 1256 005e 2946     		mov	r1, r5
 1257 0060 FFF7FEFF 		bl	send_cmd
 1258              	.LVL175:
 1259 0064 90B9     		cbnz	r0, .L110
 542:./lib/fatfs/mmc.c **** 			do {
 543:./lib/fatfs/mmc.c **** 				if (!xmit_datablock(buff, 0xFC)) break;
 1260              		.loc 1 543 0
 1261 0066 FC25     		movs	r5, #252
 1262              	.LVL176:
 1263              	.L118:
 1264 0068 3046     		mov	r0, r6
 1265 006a 2946     		mov	r1, r5
 1266 006c FFF7FEFF 		bl	xmit_datablock
 1267              	.LVL177:
 1268 0070 28B1     		cbz	r0, .L112
 544:./lib/fatfs/mmc.c **** 				buff += 512;
 1269              		.loc 1 544 0
 1270 0072 06F50076 		add	r6, r6, #512
 1271              	.LVL178:
 545:./lib/fatfs/mmc.c **** 			} while (--count);
 1272              		.loc 1 545 0
 1273 0076 601E     		subs	r0, r4, #1
 1274              	.LVL179:
 1275 0078 10F0FF04 		ands	r4, r0, #255
 1276 007c F4D1     		bne	.L118
 1277              	.LVL180:
 1278              	.L112:
 546:./lib/fatfs/mmc.c **** 			if (!xmit_datablock(0, 0xFD))	/* STOP_TRAN token */
 1279              		.loc 1 546 0
 1280 007e 0020     		movs	r0, #0
 1281 0080 FD21     		movs	r1, #253
 1282 0082 FFF7FEFF 		bl	xmit_datablock
 1283              	.LVL181:
 1284 0086 0028     		cmp	r0, #0
 547:./lib/fatfs/mmc.c **** 				count = 1;
 1285              		.loc 1 547 0
 1286 0088 08BF     		it	eq
 1287 008a 0124     		moveq	r4, #1
 1288              	.LVL182:
 1289              	.L110:
 548:./lib/fatfs/mmc.c **** 		}
 549:./lib/fatfs/mmc.c **** 	}
 550:./lib/fatfs/mmc.c **** 	deselect();
 1290              		.loc 1 550 0
 1291 008c FFF7FEFF 		bl	deselect
 1292              	.LVL183:
 551:./lib/fatfs/mmc.c **** 
 552:./lib/fatfs/mmc.c **** 	return count ? RES_ERROR : RES_OK;
 1293              		.loc 1 552 0
 1294 0090 201C     		adds	r0, r4, #0
 1295 0092 18BF     		it	ne
 1296 0094 0120     		movne	r0, #1
 1297 0096 70BD     		pop	{r4, r5, r6, pc}
 1298              	.LVL184:
 1299              	.L114:
 1300              		.cfi_def_cfa_offset 0
 1301              		.cfi_restore 4
 1302              		.cfi_restore 5
 1303              		.cfi_restore 6
 1304              		.cfi_restore 14
 528:./lib/fatfs/mmc.c **** 	if (Stat & STA_NOINIT) return RES_NOTRDY;
 1305              		.loc 1 528 0
 1306 0098 0420     		movs	r0, #4
 1307              	.LVL185:
 553:./lib/fatfs/mmc.c **** }
 1308              		.loc 1 553 0
 1309 009a 7047     		bx	lr
 1310              	.LVL186:
 1311              	.L115:
 1312              		.cfi_def_cfa_offset 16
 1313              		.cfi_offset 4, -16
 1314              		.cfi_offset 5, -12
 1315              		.cfi_offset 6, -8
 1316              		.cfi_offset 14, -4
 528:./lib/fatfs/mmc.c **** 	if (Stat & STA_NOINIT) return RES_NOTRDY;
 1317              		.loc 1 528 0
 1318 009c 0420     		movs	r0, #4
 1319              	.LVL187:
 1320 009e 70BD     		pop	{r4, r5, r6, pc}
 1321              	.LVL188:
 1322              	.L116:
 529:./lib/fatfs/mmc.c **** 	if (Stat & STA_PROTECT) return RES_WRPRT;
 1323              		.loc 1 529 0
 1324 00a0 0320     		movs	r0, #3
 1325              	.LVL189:
 1326 00a2 70BD     		pop	{r4, r5, r6, pc}
 1327              	.LVL190:
 1328              	.L117:
 530:./lib/fatfs/mmc.c **** 
 1329              		.loc 1 530 0
 1330 00a4 0220     		movs	r0, #2
 1331              	.LVL191:
 1332              		.loc 1 553 0
 1333 00a6 70BD     		pop	{r4, r5, r6, pc}
 1334              	.L122:
 1335              		.align	2
 1336              	.L121:
 1337 00a8 00000000 		.word	.LANCHOR0
 1338 00ac 00000000 		.word	.LANCHOR1
 1339              		.cfi_endproc
 1340              	.LFE44:
 1342              		.section	.text.disk_ioctl,"ax",%progbits
 1343              		.align	2
 1344              		.global	disk_ioctl
 1345              		.thumb
 1346              		.thumb_func
 1348              	disk_ioctl:
 1349              	.LFB45:
 554:./lib/fatfs/mmc.c **** #endif
 555:./lib/fatfs/mmc.c **** 
 556:./lib/fatfs/mmc.c **** 
 557:./lib/fatfs/mmc.c **** 
 558:./lib/fatfs/mmc.c **** /*-----------------------------------------------------------------------*/
 559:./lib/fatfs/mmc.c **** /* Miscellaneous Functions                                               */
 560:./lib/fatfs/mmc.c **** /*-----------------------------------------------------------------------*/
 561:./lib/fatfs/mmc.c **** 
 562:./lib/fatfs/mmc.c **** #if _USE_IOCTL
 563:./lib/fatfs/mmc.c **** DRESULT disk_ioctl (
 564:./lib/fatfs/mmc.c **** 	BYTE pdrv,		/* Physical drive nmuber (0) */
 565:./lib/fatfs/mmc.c **** 	BYTE cmd,		/* Control code */
 566:./lib/fatfs/mmc.c **** 	void *buff		/* Buffer to send/receive data block */
 567:./lib/fatfs/mmc.c **** )
 568:./lib/fatfs/mmc.c **** {
 1350              		.loc 1 568 0
 1351              		.cfi_startproc
 1352              		@ args = 0, pretend = 0, frame = 16
 1353              		@ frame_needed = 0, uses_anonymous_args = 0
 1354              	.LVL192:
 569:./lib/fatfs/mmc.c **** 	DRESULT res;
 570:./lib/fatfs/mmc.c **** 	BYTE n, csd[16], *ptr = buff;
 571:./lib/fatfs/mmc.c **** 	DWORD csz;
 572:./lib/fatfs/mmc.c **** 
 573:./lib/fatfs/mmc.c **** 
 574:./lib/fatfs/mmc.c **** 	if (pdrv) return RES_PARERR;
 1355              		.loc 1 574 0
 1356 0000 0028     		cmp	r0, #0
 1357 0002 40F02781 		bne	.L140
 575:./lib/fatfs/mmc.c **** 	if (Stat & STA_NOINIT) return RES_NOTRDY;
 1358              		.loc 1 575 0
 1359 0006 964B     		ldr	r3, .L158
 1360 0008 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1361 000a 13F0010F 		tst	r3, #1
 1362 000e 40F02381 		bne	.L141
 568:./lib/fatfs/mmc.c **** 	DRESULT res;
 1363              		.loc 1 568 0
 1364 0012 70B5     		push	{r4, r5, r6, lr}
 1365              		.cfi_def_cfa_offset 16
 1366              		.cfi_offset 4, -16
 1367              		.cfi_offset 5, -12
 1368              		.cfi_offset 6, -8
 1369              		.cfi_offset 14, -4
 1370 0014 84B0     		sub	sp, sp, #16
 1371              		.cfi_def_cfa_offset 32
 1372 0016 1446     		mov	r4, r2
 1373              	.LVL193:
 576:./lib/fatfs/mmc.c **** 
 577:./lib/fatfs/mmc.c **** 	res = RES_ERROR;
 578:./lib/fatfs/mmc.c **** 	switch (cmd) {
 1374              		.loc 1 578 0
 1375 0018 0E29     		cmp	r1, #14
 1376 001a 00F20081 		bhi	.L142
 1377 001e DFE811F0 		tbh	[pc, r1, lsl #1]
 1378              	.L127:
 1379 0022 0F00     		.2byte	(.L126-.L127)/2
 1380 0024 1500     		.2byte	(.L128-.L127)/2
 1381 0026 FE00     		.2byte	(.L142-.L127)/2
 1382 0028 5D00     		.2byte	(.L129-.L127)/2
 1383 002a FE00     		.2byte	(.L142-.L127)/2
 1384 002c FE00     		.2byte	(.L142-.L127)/2
 1385 002e FE00     		.2byte	(.L142-.L127)/2
 1386 0030 FE00     		.2byte	(.L142-.L127)/2
 1387 0032 FE00     		.2byte	(.L142-.L127)/2
 1388 0034 FE00     		.2byte	(.L142-.L127)/2
 1389 0036 B800     		.2byte	(.L130-.L127)/2
 1390 0038 BD00     		.2byte	(.L131-.L127)/2
 1391 003a CB00     		.2byte	(.L132-.L127)/2
 1392 003c D800     		.2byte	(.L133-.L127)/2
 1393 003e E900     		.2byte	(.L134-.L127)/2
 1394              		.p2align 1
 1395              	.L126:
 579:./lib/fatfs/mmc.c **** 	case CTRL_SYNC :	/* Flush write-back cache, Wait for end of internal process */
 580:./lib/fatfs/mmc.c **** 		if (select()) res = RES_OK;
 1396              		.loc 1 580 0
 1397 0040 FFF7FEFF 		bl	select
 1398              	.LVL194:
 1399 0044 B0FA80F4 		clz	r4, r0
 1400              	.LVL195:
 1401 0048 6409     		lsrs	r4, r4, #5
 1402 004a FFE0     		b	.L125
 1403              	.LVL196:
 1404              	.L128:
 581:./lib/fatfs/mmc.c **** 		break;
 582:./lib/fatfs/mmc.c **** 
 583:./lib/fatfs/mmc.c **** 	case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (WORD) */
 584:./lib/fatfs/mmc.c **** 		if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
 1405              		.loc 1 584 0
 1406 004c 0920     		movs	r0, #9
 1407              	.LVL197:
 1408 004e 0021     		movs	r1, #0
 1409              	.LVL198:
 1410 0050 FFF7FEFF 		bl	send_cmd
 1411              	.LVL199:
 1412 0054 0028     		cmp	r0, #0
 1413 0056 40F0E480 		bne	.L143
 1414              		.loc 1 584 0 is_stmt 0 discriminator 1
 1415 005a 6846     		mov	r0, sp
 1416 005c 1021     		movs	r1, #16
 1417 005e FFF7FEFF 		bl	rcvr_datablock
 1418              	.LVL200:
 1419 0062 0028     		cmp	r0, #0
 1420 0064 00F0DF80 		beq	.L144
 585:./lib/fatfs/mmc.c **** 			if ((csd[0] >> 6) == 1) {	/* SDv2? */
 1421              		.loc 1 585 0 is_stmt 1
 1422 0068 9DF80030 		ldrb	r3, [sp]	@ zero_extendqisi2
 1423 006c 9B09     		lsrs	r3, r3, #6
 1424 006e 012B     		cmp	r3, #1
 1425 0070 10D1     		bne	.L135
 1426              	.LVL201:
 586:./lib/fatfs/mmc.c **** 				csz = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
 1427              		.loc 1 586 0
 1428 0072 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 1429 0076 03F03F03 		and	r3, r3, #63
 1430 007a 1B04     		lsls	r3, r3, #16
 1431 007c 591C     		adds	r1, r3, #1
 1432 007e 9DF80920 		ldrb	r2, [sp, #9]	@ zero_extendqisi2
 1433 0082 9DF80830 		ldrb	r3, [sp, #8]	@ zero_extendqisi2
 1434              	.LVL202:
 1435 0086 02EB0323 		add	r3, r2, r3, lsl #8
 1436              	.LVL203:
 1437 008a 0B44     		add	r3, r3, r1
 587:./lib/fatfs/mmc.c **** 				*(DWORD*)buff = csz << 10;
 1438              		.loc 1 587 0
 1439 008c 9B02     		lsls	r3, r3, #10
 1440 008e 2360     		str	r3, [r4]
 588:./lib/fatfs/mmc.c **** 			} else {					/* SDv1 or MMCv3 */
 589:./lib/fatfs/mmc.c **** 				n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
 590:./lib/fatfs/mmc.c **** 				csz = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
 591:./lib/fatfs/mmc.c **** 				*(DWORD*)buff = csz << (n - 9);
 592:./lib/fatfs/mmc.c **** 			}
 593:./lib/fatfs/mmc.c **** 			res = RES_OK;
 1441              		.loc 1 593 0
 1442 0090 0024     		movs	r4, #0
 1443              	.LVL204:
 1444 0092 DBE0     		b	.L125
 1445              	.LVL205:
 1446              	.L135:
 590:./lib/fatfs/mmc.c **** 				*(DWORD*)buff = csz << (n - 9);
 1447              		.loc 1 590 0
 1448 0094 9DF80820 		ldrb	r2, [sp, #8]	@ zero_extendqisi2
 1449 0098 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 1450              	.LVL206:
 1451 009c 9B00     		lsls	r3, r3, #2
 1452              	.LVL207:
 1453 009e 03EB9213 		add	r3, r3, r2, lsr #6
 1454 00a2 9DF80620 		ldrb	r2, [sp, #6]	@ zero_extendqisi2
 1455 00a6 02F00302 		and	r2, r2, #3
 1456 00aa 03EB8223 		add	r3, r3, r2, lsl #10
 1457 00ae 5A1C     		adds	r2, r3, #1
 589:./lib/fatfs/mmc.c **** 				csz = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
 1458              		.loc 1 589 0
 1459 00b0 9DF80530 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
 1460 00b4 03F00F03 		and	r3, r3, #15
 1461 00b8 9DF80A10 		ldrb	r1, [sp, #10]	@ zero_extendqisi2
 1462 00bc 03EBD113 		add	r3, r3, r1, lsr #7
 1463 00c0 0233     		adds	r3, r3, #2
 1464 00c2 9DF80910 		ldrb	r1, [sp, #9]	@ zero_extendqisi2
 1465 00c6 01F00301 		and	r1, r1, #3
 1466 00ca 03EB4103 		add	r3, r3, r1, lsl #1
 591:./lib/fatfs/mmc.c **** 			}
 1467              		.loc 1 591 0
 1468 00ce DBB2     		uxtb	r3, r3
 1469 00d0 093B     		subs	r3, r3, #9
 1470 00d2 02FA03F3 		lsl	r3, r2, r3
 1471 00d6 2360     		str	r3, [r4]
 1472              		.loc 1 593 0
 1473 00d8 0024     		movs	r4, #0
 1474              	.LVL208:
 1475 00da B7E0     		b	.L125
 1476              	.LVL209:
 1477              	.L129:
 594:./lib/fatfs/mmc.c **** 		}
 595:./lib/fatfs/mmc.c **** 		break;
 596:./lib/fatfs/mmc.c **** 
 597:./lib/fatfs/mmc.c **** 	case GET_BLOCK_SIZE :	/* Get erase block size in unit of sectors (DWORD) */
 598:./lib/fatfs/mmc.c **** 		if (CardType & CT_SD2) {	/* SDv2? */
 1478              		.loc 1 598 0
 1479 00dc 614B     		ldr	r3, .L158+4
 1480 00de 1B68     		ldr	r3, [r3]
 1481 00e0 13F0040F 		tst	r3, #4
 1482 00e4 21D0     		beq	.L136
 599:./lib/fatfs/mmc.c **** 			if (send_cmd(ACMD13, 0) == 0) {		/* Read SD status */
 1483              		.loc 1 599 0
 1484 00e6 8D20     		movs	r0, #141
 1485              	.LVL210:
 1486 00e8 0021     		movs	r1, #0
 1487              	.LVL211:
 1488 00ea FFF7FEFF 		bl	send_cmd
 1489              	.LVL212:
 1490 00ee 0028     		cmp	r0, #0
 1491 00f0 40F09B80 		bne	.L145
 600:./lib/fatfs/mmc.c **** 				xchg_spi(0xFF);
 1492              		.loc 1 600 0
 1493 00f4 FF20     		movs	r0, #255
 1494 00f6 FFF7FEFF 		bl	xchg_spi
 1495              	.LVL213:
 601:./lib/fatfs/mmc.c **** 				if (rcvr_datablock(csd, 16)) {				/* Read partial block */
 1496              		.loc 1 601 0
 1497 00fa 6846     		mov	r0, sp
 1498 00fc 1021     		movs	r1, #16
 1499 00fe FFF7FEFF 		bl	rcvr_datablock
 1500              	.LVL214:
 1501 0102 0028     		cmp	r0, #0
 1502 0104 00F09380 		beq	.L146
 1503 0108 3025     		movs	r5, #48
 602:./lib/fatfs/mmc.c **** 					for (n = 64 - 16; n; n--) xchg_spi(0xFF);	/* Purge trailing data */
 1504              		.loc 1 602 0
 1505 010a FF26     		movs	r6, #255
 1506              	.L137:
 1507              	.LVL215:
 1508              		.loc 1 602 0 is_stmt 0 discriminator 3
 1509 010c 3046     		mov	r0, r6
 1510 010e FFF7FEFF 		bl	xchg_spi
 1511              	.LVL216:
 1512 0112 6B1E     		subs	r3, r5, #1
 1513 0114 13F0FF05 		ands	r5, r3, #255
 1514              	.LVL217:
 1515 0118 F8D1     		bne	.L137
 603:./lib/fatfs/mmc.c **** 					*(DWORD*)buff = 16UL << (csd[10] >> 4);
 1516              		.loc 1 603 0 is_stmt 1
 1517 011a 9DF80A20 		ldrb	r2, [sp, #10]	@ zero_extendqisi2
 1518 011e 1209     		lsrs	r2, r2, #4
 1519 0120 1023     		movs	r3, #16
 1520 0122 9340     		lsls	r3, r3, r2
 1521 0124 2360     		str	r3, [r4]
 1522              	.LVL218:
 604:./lib/fatfs/mmc.c **** 					res = RES_OK;
 1523              		.loc 1 604 0
 1524 0126 0024     		movs	r4, #0
 1525              	.LVL219:
 1526 0128 90E0     		b	.L125
 1527              	.LVL220:
 1528              	.L136:
 605:./lib/fatfs/mmc.c **** 				}
 606:./lib/fatfs/mmc.c **** 			}
 607:./lib/fatfs/mmc.c **** 		} else {					/* SDv1 or MMCv3 */
 608:./lib/fatfs/mmc.c **** 			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {	/* Read CSD */
 1529              		.loc 1 608 0
 1530 012a 0920     		movs	r0, #9
 1531              	.LVL221:
 1532 012c 0021     		movs	r1, #0
 1533              	.LVL222:
 1534 012e FFF7FEFF 		bl	send_cmd
 1535              	.LVL223:
 1536 0132 0028     		cmp	r0, #0
 1537 0134 7DD1     		bne	.L147
 1538              		.loc 1 608 0 is_stmt 0 discriminator 1
 1539 0136 6846     		mov	r0, sp
 1540 0138 1021     		movs	r1, #16
 1541 013a FFF7FEFF 		bl	rcvr_datablock
 1542              	.LVL224:
 1543 013e 0028     		cmp	r0, #0
 1544 0140 79D0     		beq	.L148
 609:./lib/fatfs/mmc.c **** 				if (CardType & CT_SD1) {	/* SDv1 */
 1545              		.loc 1 609 0 is_stmt 1
 1546 0142 484B     		ldr	r3, .L158+4
 1547 0144 1B68     		ldr	r3, [r3]
 1548 0146 13F0020F 		tst	r3, #2
 1549 014a 11D0     		beq	.L138
 610:./lib/fatfs/mmc.c **** 					*(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) 
 1550              		.loc 1 610 0
 1551 014c 9DF80A30 		ldrb	r3, [sp, #10]	@ zero_extendqisi2
 1552 0150 03F03F02 		and	r2, r3, #63
 1553 0154 9DF80B30 		ldrb	r3, [sp, #11]	@ zero_extendqisi2
 1554 0158 DB09     		lsrs	r3, r3, #7
 1555 015a 03EB4203 		add	r3, r3, r2, lsl #1
 1556 015e 0133     		adds	r3, r3, #1
 1557 0160 9DF80D20 		ldrb	r2, [sp, #13]	@ zero_extendqisi2
 1558 0164 9209     		lsrs	r2, r2, #6
 1559 0166 013A     		subs	r2, r2, #1
 1560 0168 9340     		lsls	r3, r3, r2
 1561 016a 2360     		str	r3, [r4]
 611:./lib/fatfs/mmc.c **** 				} else {					/* MMCv3 */
 612:./lib/fatfs/mmc.c **** 					*(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) 
 613:./lib/fatfs/mmc.c **** 				}
 614:./lib/fatfs/mmc.c **** 				res = RES_OK;
 1562              		.loc 1 614 0
 1563 016c 0024     		movs	r4, #0
 1564              	.LVL225:
 1565 016e 6DE0     		b	.L125
 1566              	.LVL226:
 1567              	.L138:
 612:./lib/fatfs/mmc.c **** 				}
 1568              		.loc 1 612 0
 1569 0170 9DF80B30 		ldrb	r3, [sp, #11]	@ zero_extendqisi2
 1570 0174 9DF80A10 		ldrb	r1, [sp, #10]	@ zero_extendqisi2
 1571 0178 C1F38401 		ubfx	r1, r1, #2, #5
 1572 017c 03F00300 		and	r0, r3, #3
 1573 0180 5A09     		lsrs	r2, r3, #5
 1574 0182 02EBC002 		add	r2, r2, r0, lsl #3
 1575 0186 531C     		adds	r3, r2, #1
 1576 0188 01FB0333 		mla	r3, r1, r3, r3
 1577 018c 2360     		str	r3, [r4]
 1578              		.loc 1 614 0
 1579 018e 0024     		movs	r4, #0
 1580              	.LVL227:
 1581 0190 5CE0     		b	.L125
 1582              	.LVL228:
 1583              	.L130:
 615:./lib/fatfs/mmc.c **** 			}
 616:./lib/fatfs/mmc.c **** 		}
 617:./lib/fatfs/mmc.c **** 		break;
 618:./lib/fatfs/mmc.c **** 
 619:./lib/fatfs/mmc.c **** 	case MMC_GET_TYPE :		/* Get card type flags (1 byte) */
 620:./lib/fatfs/mmc.c **** 		*ptr = CardType;
 1584              		.loc 1 620 0
 1585 0192 344B     		ldr	r3, .L158+4
 1586 0194 1B68     		ldr	r3, [r3]
 1587 0196 1370     		strb	r3, [r2]
 1588              	.LVL229:
 621:./lib/fatfs/mmc.c **** 		res = RES_OK;
 1589              		.loc 1 621 0
 1590 0198 0024     		movs	r4, #0
 622:./lib/fatfs/mmc.c **** 		break;
 1591              		.loc 1 622 0
 1592 019a 57E0     		b	.L125
 1593              	.LVL230:
 1594              	.L131:
 623:./lib/fatfs/mmc.c **** 
 624:./lib/fatfs/mmc.c **** 	case MMC_GET_CSD :	/* Receive CSD as a data block (16 bytes) */
 625:./lib/fatfs/mmc.c **** 		if ((send_cmd(CMD9, 0) == 0)	/* READ_CSD */
 1595              		.loc 1 625 0
 1596 019c 0920     		movs	r0, #9
 1597              	.LVL231:
 1598 019e 0021     		movs	r1, #0
 1599              	.LVL232:
 1600 01a0 FFF7FEFF 		bl	send_cmd
 1601              	.LVL233:
 1602 01a4 0028     		cmp	r0, #0
 1603 01a6 48D1     		bne	.L149
 626:./lib/fatfs/mmc.c **** 			&& rcvr_datablock(buff, 16))
 1604              		.loc 1 626 0
 1605 01a8 2046     		mov	r0, r4
 1606 01aa 1021     		movs	r1, #16
 1607 01ac FFF7FEFF 		bl	rcvr_datablock
 1608              	.LVL234:
 580:./lib/fatfs/mmc.c **** 		break;
 1609              		.loc 1 580 0
 1610 01b0 B0FA80F4 		clz	r4, r0
 1611              	.LVL235:
 1612 01b4 6409     		lsrs	r4, r4, #5
 1613 01b6 49E0     		b	.L125
 1614              	.LVL236:
 1615              	.L132:
 627:./lib/fatfs/mmc.c **** 			res = RES_OK;
 628:./lib/fatfs/mmc.c **** 		break;
 629:./lib/fatfs/mmc.c **** 
 630:./lib/fatfs/mmc.c **** 	case MMC_GET_CID :	/* Receive CID as a data block (16 bytes) */
 631:./lib/fatfs/mmc.c **** 		if ((send_cmd(CMD10, 0) == 0)	/* READ_CID */
 1616              		.loc 1 631 0
 1617 01b8 0A20     		movs	r0, #10
 1618              	.LVL237:
 1619 01ba 0021     		movs	r1, #0
 1620              	.LVL238:
 1621 01bc FFF7FEFF 		bl	send_cmd
 1622              	.LVL239:
 1623 01c0 E8BB     		cbnz	r0, .L150
 632:./lib/fatfs/mmc.c **** 			&& rcvr_datablock(buff, 16))
 1624              		.loc 1 632 0
 1625 01c2 2046     		mov	r0, r4
 1626 01c4 1021     		movs	r1, #16
 1627 01c6 FFF7FEFF 		bl	rcvr_datablock
 1628              	.LVL240:
 580:./lib/fatfs/mmc.c **** 		break;
 1629              		.loc 1 580 0
 1630 01ca B0FA80F4 		clz	r4, r0
 1631              	.LVL241:
 1632 01ce 6409     		lsrs	r4, r4, #5
 1633 01d0 3CE0     		b	.L125
 1634              	.LVL242:
 1635              	.L133:
 633:./lib/fatfs/mmc.c **** 			res = RES_OK;
 634:./lib/fatfs/mmc.c **** 		break;
 635:./lib/fatfs/mmc.c **** 
 636:./lib/fatfs/mmc.c **** 	case MMC_GET_OCR :	/* Receive OCR as an R3 resp (4 bytes) */
 637:./lib/fatfs/mmc.c **** 		if (send_cmd(CMD58, 0) == 0) {	/* READ_OCR */
 1636              		.loc 1 637 0
 1637 01d2 3A20     		movs	r0, #58
 1638              	.LVL243:
 1639 01d4 0021     		movs	r1, #0
 1640              	.LVL244:
 1641 01d6 FFF7FEFF 		bl	send_cmd
 1642              	.LVL245:
 1643 01da 90BB     		cbnz	r0, .L151
 1644 01dc 651E     		subs	r5, r4, #1
 1645 01de 0334     		adds	r4, r4, #3
 1646              	.LVL246:
 638:./lib/fatfs/mmc.c **** 			for (n = 0; n < 4; n++)
 639:./lib/fatfs/mmc.c **** 				*((BYTE*)buff+n) = xchg_spi(0xFF);
 1647              		.loc 1 639 0
 1648 01e0 FF26     		movs	r6, #255
 1649              	.L139:
 1650              	.LVL247:
 1651              		.loc 1 639 0 is_stmt 0 discriminator 3
 1652 01e2 3046     		mov	r0, r6
 1653 01e4 FFF7FEFF 		bl	xchg_spi
 1654              	.LVL248:
 1655 01e8 05F8010F 		strb	r0, [r5, #1]!
 1656              	.LVL249:
 638:./lib/fatfs/mmc.c **** 			for (n = 0; n < 4; n++)
 1657              		.loc 1 638 0 is_stmt 1 discriminator 3
 1658 01ec A542     		cmp	r5, r4
 1659 01ee F8D1     		bne	.L139
 640:./lib/fatfs/mmc.c **** 			res = RES_OK;
 1660              		.loc 1 640 0
 1661 01f0 0024     		movs	r4, #0
 1662              	.LVL250:
 1663 01f2 2BE0     		b	.L125
 1664              	.LVL251:
 1665              	.L134:
 641:./lib/fatfs/mmc.c **** 		}
 642:./lib/fatfs/mmc.c **** 		break;
 643:./lib/fatfs/mmc.c **** 
 644:./lib/fatfs/mmc.c **** 	case MMC_GET_SDSTAT :	/* Receive SD status as a data block (64 bytes) */
 645:./lib/fatfs/mmc.c **** 		if ((CardType & CT_SD2) && send_cmd(ACMD13, 0) == 0) {	/* SD_STATUS */
 1666              		.loc 1 645 0
 1667 01f4 1B4B     		ldr	r3, .L158+4
 1668 01f6 1B68     		ldr	r3, [r3]
 1669 01f8 13F0040F 		tst	r3, #4
 1670 01fc 23D0     		beq	.L152
 1671              		.loc 1 645 0 is_stmt 0 discriminator 1
 1672 01fe 8D20     		movs	r0, #141
 1673              	.LVL252:
 1674 0200 0021     		movs	r1, #0
 1675              	.LVL253:
 1676 0202 FFF7FEFF 		bl	send_cmd
 1677              	.LVL254:
 1678 0206 00BB     		cbnz	r0, .L153
 646:./lib/fatfs/mmc.c **** 			xchg_spi(0xFF);
 1679              		.loc 1 646 0 is_stmt 1
 1680 0208 FF20     		movs	r0, #255
 1681 020a FFF7FEFF 		bl	xchg_spi
 1682              	.LVL255:
 647:./lib/fatfs/mmc.c **** 			if (rcvr_datablock(buff, 64))
 1683              		.loc 1 647 0
 1684 020e 2046     		mov	r0, r4
 1685 0210 4021     		movs	r1, #64
 1686 0212 FFF7FEFF 		bl	rcvr_datablock
 1687              	.LVL256:
 580:./lib/fatfs/mmc.c **** 		break;
 1688              		.loc 1 580 0
 1689 0216 B0FA80F4 		clz	r4, r0
 1690              	.LVL257:
 1691 021a 6409     		lsrs	r4, r4, #5
 1692 021c 16E0     		b	.L125
 1693              	.LVL258:
 1694              	.L142:
 648:./lib/fatfs/mmc.c **** 				res = RES_OK;
 649:./lib/fatfs/mmc.c **** 		}
 650:./lib/fatfs/mmc.c **** 		break;
 651:./lib/fatfs/mmc.c **** 
 652:./lib/fatfs/mmc.c **** 	default:
 653:./lib/fatfs/mmc.c **** 		res = RES_PARERR;
 1695              		.loc 1 653 0
 1696 021e 0424     		movs	r4, #4
 1697 0220 14E0     		b	.L125
 1698              	.LVL259:
 1699              	.L143:
 577:./lib/fatfs/mmc.c **** 	switch (cmd) {
 1700              		.loc 1 577 0
 1701 0222 0124     		movs	r4, #1
 1702              	.LVL260:
 1703 0224 12E0     		b	.L125
 1704              	.LVL261:
 1705              	.L144:
 1706 0226 0124     		movs	r4, #1
 1707              	.LVL262:
 1708 0228 10E0     		b	.L125
 1709              	.LVL263:
 1710              	.L145:
 1711 022a 0124     		movs	r4, #1
 1712              	.LVL264:
 1713 022c 0EE0     		b	.L125
 1714              	.LVL265:
 1715              	.L146:
 1716 022e 0124     		movs	r4, #1
 1717              	.LVL266:
 1718 0230 0CE0     		b	.L125
 1719              	.LVL267:
 1720              	.L147:
 1721 0232 0124     		movs	r4, #1
 1722              	.LVL268:
 1723 0234 0AE0     		b	.L125
 1724              	.LVL269:
 1725              	.L148:
 1726 0236 0124     		movs	r4, #1
 1727              	.LVL270:
 1728 0238 08E0     		b	.L125
 1729              	.LVL271:
 1730              	.L149:
 1731 023a 0124     		movs	r4, #1
 1732              	.LVL272:
 1733 023c 06E0     		b	.L125
 1734              	.LVL273:
 1735              	.L150:
 1736 023e 0124     		movs	r4, #1
 1737              	.LVL274:
 1738 0240 04E0     		b	.L125
 1739              	.LVL275:
 1740              	.L151:
 1741 0242 0124     		movs	r4, #1
 1742              	.LVL276:
 1743 0244 02E0     		b	.L125
 1744              	.LVL277:
 1745              	.L152:
 1746 0246 0124     		movs	r4, #1
 1747 0248 00E0     		b	.L125
 1748              	.LVL278:
 1749              	.L153:
 1750 024a 0124     		movs	r4, #1
 1751              	.LVL279:
 1752              	.L125:
 654:./lib/fatfs/mmc.c **** 	}
 655:./lib/fatfs/mmc.c **** 
 656:./lib/fatfs/mmc.c **** 	deselect();
 1753              		.loc 1 656 0
 1754 024c FFF7FEFF 		bl	deselect
 1755              	.LVL280:
 657:./lib/fatfs/mmc.c **** 
 658:./lib/fatfs/mmc.c **** 	return res;
 1756              		.loc 1 658 0
 1757 0250 2046     		mov	r0, r4
 1758 0252 03E0     		b	.L124
 1759              	.LVL281:
 1760              	.L140:
 1761              		.cfi_def_cfa_offset 0
 1762              		.cfi_restore 4
 1763              		.cfi_restore 5
 1764              		.cfi_restore 6
 1765              		.cfi_restore 14
 574:./lib/fatfs/mmc.c **** 	if (Stat & STA_NOINIT) return RES_NOTRDY;
 1766              		.loc 1 574 0
 1767 0254 0420     		movs	r0, #4
 1768              	.LVL282:
 1769 0256 7047     		bx	lr
 1770              	.LVL283:
 1771              	.L141:
 575:./lib/fatfs/mmc.c **** 
 1772              		.loc 1 575 0
 1773 0258 0320     		movs	r0, #3
 1774              	.LVL284:
 1775 025a 7047     		bx	lr
 1776              	.LVL285:
 1777              	.L124:
 1778              		.cfi_def_cfa_offset 32
 1779              		.cfi_offset 4, -16
 1780              		.cfi_offset 5, -12
 1781              		.cfi_offset 6, -8
 1782              		.cfi_offset 14, -4
 659:./lib/fatfs/mmc.c **** }
 1783              		.loc 1 659 0
 1784 025c 04B0     		add	sp, sp, #16
 1785              		.cfi_def_cfa_offset 16
 1786              		@ sp needed
 1787 025e 70BD     		pop	{r4, r5, r6, pc}
 1788              	.LVL286:
 1789              	.L159:
 1790              		.align	2
 1791              	.L158:
 1792 0260 00000000 		.word	.LANCHOR0
 1793 0264 00000000 		.word	.LANCHOR1
 1794              		.cfi_endproc
 1795              	.LFE45:
 1797              		.section	.text.get_fattime,"ax",%progbits
 1798              		.align	2
 1799              		.global	get_fattime
 1800              		.thumb
 1801              		.thumb_func
 1803              	get_fattime:
 1804              	.LFB46:
 660:./lib/fatfs/mmc.c **** #endif
 661:./lib/fatfs/mmc.c **** 
 662:./lib/fatfs/mmc.c **** 
 663:./lib/fatfs/mmc.c **** /*---------------------------------------------------------*/
 664:./lib/fatfs/mmc.c **** /* User Provided Timer Function for FatFs module           */
 665:./lib/fatfs/mmc.c **** /*---------------------------------------------------------*/
 666:./lib/fatfs/mmc.c **** /* This is a real time clock service to be called from     */
 667:./lib/fatfs/mmc.c **** /* FatFs module. Any valid time must be returned even if   */
 668:./lib/fatfs/mmc.c **** /* the system does not support a real time clock.          */
 669:./lib/fatfs/mmc.c **** /* This is not required in read-only configuration.        */
 670:./lib/fatfs/mmc.c **** 
 671:./lib/fatfs/mmc.c **** DWORD get_fattime (void)
 672:./lib/fatfs/mmc.c **** {
 1805              		.loc 1 672 0
 1806              		.cfi_startproc
 1807              		@ args = 0, pretend = 0, frame = 0
 1808              		@ frame_needed = 0, uses_anonymous_args = 0
 1809              		@ link register save eliminated.
 673:./lib/fatfs/mmc.c ****   /* No RTC supprt. Return a fixed value 2013/5/10 0:00:00 */
 674:./lib/fatfs/mmc.c ****   return    ((DWORD)(2013 - 1980) << 25)  /* Y */
 675:./lib/fatfs/mmc.c ****       | ((DWORD)5  << 21)       /* M */
 676:./lib/fatfs/mmc.c ****       | ((DWORD)10 << 16)       /* D */
 677:./lib/fatfs/mmc.c ****       | ((DWORD)0  << 11)       /* H */
 678:./lib/fatfs/mmc.c ****       | ((DWORD)0  << 5)        /* M */
 679:./lib/fatfs/mmc.c ****       | ((DWORD)0  >> 1);       /* S */
 680:./lib/fatfs/mmc.c **** }
 1810              		.loc 1 680 0
 1811 0000 0048     		ldr	r0, .L161
 1812 0002 7047     		bx	lr
 1813              	.L162:
 1814              		.align	2
 1815              	.L161:
 1816 0004 0000AA42 		.word	1118437376
 1817              		.cfi_endproc
 1818              	.LFE46:
 1820              		.section	.bss.CardType,"aw",%nobits
 1821              		.align	2
 1822              		.set	.LANCHOR1,. + 0
 1825              	CardType:
 1826 0000 00000000 		.space	4
 1827              		.section	.data.Stat,"aw",%progbits
 1828              		.set	.LANCHOR0,. + 0
 1831              	Stat:
 1832 0000 01       		.byte	1
 1833              		.text
 1834              	.Letext0:
 1835              		.file 2 "../../../Source/third_party/fatfs/src/integer.h"
 1836              		.file 3 "../../../Source/third_party/fatfs/src/diskio.h"
 1837              		.file 4 "c:\\program files (x86)\\gnu tools arm embedded\\4.9 2015q1\\arm-none-eabi\\include\\mach
 1838              		.file 5 "c:\\program files (x86)\\gnu tools arm embedded\\4.9 2015q1\\arm-none-eabi\\include\\stdi
 1839              		.file 6 "./lib/CMSIS/CM3/DeviceSupport/ST/STM32F10x/stm32f10x.h"
 1840              		.file 7 "./lib/STM32F10x_StdPeriph_Driver/inc/stm32f10x_gpio.h"
 1841              		.file 8 "./lib/STM32F10x_StdPeriph_Driver/inc/stm32f10x_spi.h"
 1842              		.file 9 "../../../Source/ARMCM3_STM32/types.h"
 1843              		.file 10 "./lib/STM32F10x_StdPeriph_Driver/inc/stm32f10x_rcc.h"
 1844              		.file 11 "./lib/CMSIS/CM3/CoreSupport/core_cm3.h"
 1845              		.file 12 "../../../Source/ARMCM3_STM32/timer.h"
DEFINED SYMBOLS
                            *ABS*:00000000 mmc.c
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:19     .text.xchg_spi:00000000 $t
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:23     .text.xchg_spi:00000000 xchg_spi
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:64     .text.xchg_spi:00000024 $d
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:69     .text.wait_ready:00000000 $t
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:73     .text.wait_ready:00000000 wait_ready
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:118    .text.deselect:00000000 $t
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:122    .text.deselect:00000000 deselect
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:145    .text.deselect:00000014 $d
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:150    .text.select:00000000 $t
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:154    .text.select:00000000 select
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:193    .text.select:00000028 $d
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:198    .text.send_cmd:00000000 $t
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:202    .text.send_cmd:00000000 send_cmd
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:324    .text.xmit_datablock:00000000 $t
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:328    .text.xmit_datablock:00000000 xmit_datablock
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:405    .text.rcvr_datablock:00000000 $t
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:409    .text.rcvr_datablock:00000000 rcvr_datablock
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:506    .text.disk_initialize:00000000 $t
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:511    .text.disk_initialize:00000000 disk_initialize
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:991    .text.disk_initialize:000002d0 $d
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:999    .text.disk_status:00000000 $t
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:1004   .text.disk_status:00000000 disk_status
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:1030   .text.disk_status:00000010 $d
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:1035   .text.disk_read:00000000 $t
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:1040   .text.disk_read:00000000 disk_read
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:1170   .text.disk_read:00000088 $d
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:1176   .text.disk_write:00000000 $t
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:1181   .text.disk_write:00000000 disk_write
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:1337   .text.disk_write:000000a8 $d
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:1343   .text.disk_ioctl:00000000 $t
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:1348   .text.disk_ioctl:00000000 disk_ioctl
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:1379   .text.disk_ioctl:00000022 $d
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:1394   .text.disk_ioctl:00000040 $t
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:1792   .text.disk_ioctl:00000260 $d
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:1798   .text.get_fattime:00000000 $t
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:1803   .text.get_fattime:00000000 get_fattime
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:1816   .text.get_fattime:00000004 $d
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:1821   .bss.CardType:00000000 $d
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:1825   .bss.CardType:00000000 CardType
C:\Users\lwngim1\AppData\Local\Temp\cczeyUZQ.s:1831   .data.Stat:00000000 Stat
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
SPI_I2S_SendData
SPI_I2S_GetFlagStatus
SPI_I2S_ReceiveData
TimerGet
GPIO_SetBits
GPIO_ResetBits
RCC_APB2PeriphClockCmd
RCC_APB1PeriphClockCmd
GPIO_Init
SPI_Init
SPI_CalculateCRC
SPI_Cmd

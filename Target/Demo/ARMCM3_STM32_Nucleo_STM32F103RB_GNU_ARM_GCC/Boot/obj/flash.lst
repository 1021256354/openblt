   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"flash.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.FlashLock,"ax",%progbits
  19              		.align	2
  20              		.thumb
  21              		.thumb_func
  23              	FlashLock:
  24              	.LFB13:
  25              		.file 1 "../../../Source/ARMCM3_STM32/flash.c"
   1:../../../Source/ARMCM3_STM32/flash.c **** /************************************************************************************//**
   2:../../../Source/ARMCM3_STM32/flash.c **** * \file         Source\ARMCM3_STM32\flash.c
   3:../../../Source/ARMCM3_STM32/flash.c **** * \brief        Bootloader flash driver source file.
   4:../../../Source/ARMCM3_STM32/flash.c **** * \ingroup      Target_ARMCM3_STM32
   5:../../../Source/ARMCM3_STM32/flash.c **** * \internal
   6:../../../Source/ARMCM3_STM32/flash.c **** *----------------------------------------------------------------------------------------
   7:../../../Source/ARMCM3_STM32/flash.c **** *                          C O P Y R I G H T
   8:../../../Source/ARMCM3_STM32/flash.c **** *----------------------------------------------------------------------------------------
   9:../../../Source/ARMCM3_STM32/flash.c **** *   Copyright (c) 2011  by Feaser    http://www.feaser.com    All rights reserved
  10:../../../Source/ARMCM3_STM32/flash.c **** *
  11:../../../Source/ARMCM3_STM32/flash.c **** *----------------------------------------------------------------------------------------
  12:../../../Source/ARMCM3_STM32/flash.c **** *                            L I C E N S E
  13:../../../Source/ARMCM3_STM32/flash.c **** *----------------------------------------------------------------------------------------
  14:../../../Source/ARMCM3_STM32/flash.c **** * This file is part of OpenBLT. OpenBLT is free software: you can redistribute it and/or
  15:../../../Source/ARMCM3_STM32/flash.c **** * modify it under the terms of the GNU General Public License as published by the Free
  16:../../../Source/ARMCM3_STM32/flash.c **** * Software Foundation, either version 3 of the License, or (at your option) any later
  17:../../../Source/ARMCM3_STM32/flash.c **** * version.
  18:../../../Source/ARMCM3_STM32/flash.c **** *
  19:../../../Source/ARMCM3_STM32/flash.c **** * OpenBLT is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
  20:../../../Source/ARMCM3_STM32/flash.c **** * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
  21:../../../Source/ARMCM3_STM32/flash.c **** * PURPOSE. See the GNU General Public License for more details.
  22:../../../Source/ARMCM3_STM32/flash.c **** *
  23:../../../Source/ARMCM3_STM32/flash.c **** * You should have received a copy of the GNU General Public License along with OpenBLT.
  24:../../../Source/ARMCM3_STM32/flash.c **** * If not, see <http://www.gnu.org/licenses/>.
  25:../../../Source/ARMCM3_STM32/flash.c **** *
  26:../../../Source/ARMCM3_STM32/flash.c **** * A special exception to the GPL is included to allow you to distribute a combined work 
  27:../../../Source/ARMCM3_STM32/flash.c **** * that includes OpenBLT without being obliged to provide the source code for any 
  28:../../../Source/ARMCM3_STM32/flash.c **** * proprietary components. The exception text is included at the bottom of the license
  29:../../../Source/ARMCM3_STM32/flash.c **** * file <license.html>.
  30:../../../Source/ARMCM3_STM32/flash.c **** * 
  31:../../../Source/ARMCM3_STM32/flash.c **** * \endinternal
  32:../../../Source/ARMCM3_STM32/flash.c **** ****************************************************************************************/
  33:../../../Source/ARMCM3_STM32/flash.c **** 
  34:../../../Source/ARMCM3_STM32/flash.c **** /****************************************************************************************
  35:../../../Source/ARMCM3_STM32/flash.c **** * Include files
  36:../../../Source/ARMCM3_STM32/flash.c **** ****************************************************************************************/
  37:../../../Source/ARMCM3_STM32/flash.c **** #include "boot.h"                                /* bootloader generic header          */
  38:../../../Source/ARMCM3_STM32/flash.c **** 
  39:../../../Source/ARMCM3_STM32/flash.c **** 
  40:../../../Source/ARMCM3_STM32/flash.c **** /****************************************************************************************
  41:../../../Source/ARMCM3_STM32/flash.c **** * Macro definitions
  42:../../../Source/ARMCM3_STM32/flash.c **** ****************************************************************************************/
  43:../../../Source/ARMCM3_STM32/flash.c **** /** \brief Value for an invalid flash sector. */
  44:../../../Source/ARMCM3_STM32/flash.c **** #define FLASH_INVALID_SECTOR            (0xff)
  45:../../../Source/ARMCM3_STM32/flash.c **** /** \brief Value for an invalid flash address. */
  46:../../../Source/ARMCM3_STM32/flash.c **** #define FLASH_INVALID_ADDRESS           (0xffffffff)
  47:../../../Source/ARMCM3_STM32/flash.c **** /** \brief Standard size of a flash block for writing. */
  48:../../../Source/ARMCM3_STM32/flash.c **** #define FLASH_WRITE_BLOCK_SIZE          (512)
  49:../../../Source/ARMCM3_STM32/flash.c **** /** \brief Total numbers of sectors in array flashLayout[]. */
  50:../../../Source/ARMCM3_STM32/flash.c **** #define FLASH_TOTAL_SECTORS             (sizeof(flashLayout)/sizeof(flashLayout[0]))
  51:../../../Source/ARMCM3_STM32/flash.c **** #if (BOOT_NVM_SIZE_KB > 128)
  52:../../../Source/ARMCM3_STM32/flash.c **** /** \brief Number of bytes to erase per erase operation. */
  53:../../../Source/ARMCM3_STM32/flash.c **** #define FLASH_ERASE_BLOCK_SIZE          (0x800)
  54:../../../Source/ARMCM3_STM32/flash.c **** #else
  55:../../../Source/ARMCM3_STM32/flash.c **** /** \brief Number of bytes to erase per erase operation. */
  56:../../../Source/ARMCM3_STM32/flash.c **** #define FLASH_ERASE_BLOCK_SIZE          (0x400)
  57:../../../Source/ARMCM3_STM32/flash.c **** #endif
  58:../../../Source/ARMCM3_STM32/flash.c **** /** \brief Macro for accessing the flash control registers. */
  59:../../../Source/ARMCM3_STM32/flash.c **** #define FLASH                           ((tFlashRegs *) (blt_int32u)0x40022000)
  60:../../../Source/ARMCM3_STM32/flash.c **** /** \brief Offset into the user program's vector table where the checksum is located. */
  61:../../../Source/ARMCM3_STM32/flash.c **** #define FLASH_VECTOR_TABLE_CS_OFFSET    (0x150)
  62:../../../Source/ARMCM3_STM32/flash.c **** #define FLASH_KEY1                      ((blt_int32u)0x45670123)
  63:../../../Source/ARMCM3_STM32/flash.c **** #define FLASH_KEY2                      ((blt_int32u)0xCDEF89AB)
  64:../../../Source/ARMCM3_STM32/flash.c **** #define FLASH_LOCK_BIT                  ((blt_int32u)0x00000080)
  65:../../../Source/ARMCM3_STM32/flash.c **** #define FLASH_EOP_BIT                   ((blt_int32u)0x00000020)
  66:../../../Source/ARMCM3_STM32/flash.c **** #define FLASH_PGERR_BIT                 ((blt_int32u)0x00000004)
  67:../../../Source/ARMCM3_STM32/flash.c **** #define FLASH_WRPRTERR_BIT              ((blt_int32u)0x00000010)
  68:../../../Source/ARMCM3_STM32/flash.c **** #define FLASH_BSY_BIT                   ((blt_int32u)0x00000001)
  69:../../../Source/ARMCM3_STM32/flash.c **** #define FLASH_PER_BIT                   ((blt_int32u)0x00000002)
  70:../../../Source/ARMCM3_STM32/flash.c **** #define FLASH_STRT_BIT                  ((blt_int32u)0x00000040)
  71:../../../Source/ARMCM3_STM32/flash.c **** #define FLASH_PG_BIT                    ((blt_int32u)0x00000001)
  72:../../../Source/ARMCM3_STM32/flash.c **** 
  73:../../../Source/ARMCM3_STM32/flash.c **** 
  74:../../../Source/ARMCM3_STM32/flash.c **** /****************************************************************************************
  75:../../../Source/ARMCM3_STM32/flash.c **** * Type definitions
  76:../../../Source/ARMCM3_STM32/flash.c **** ****************************************************************************************/
  77:../../../Source/ARMCM3_STM32/flash.c **** /** \brief Flash sector descriptor type. */
  78:../../../Source/ARMCM3_STM32/flash.c **** typedef struct 
  79:../../../Source/ARMCM3_STM32/flash.c **** {
  80:../../../Source/ARMCM3_STM32/flash.c ****   blt_addr   sector_start;                       /**< sector start address             */
  81:../../../Source/ARMCM3_STM32/flash.c ****   blt_int32u sector_size;                        /**< sector size in bytes             */
  82:../../../Source/ARMCM3_STM32/flash.c ****   blt_int8u  sector_num;                         /**< sector number                    */
  83:../../../Source/ARMCM3_STM32/flash.c **** } tFlashSector;
  84:../../../Source/ARMCM3_STM32/flash.c **** 
  85:../../../Source/ARMCM3_STM32/flash.c **** /** \brief    Structure type for grouping flash block information.
  86:../../../Source/ARMCM3_STM32/flash.c ****  *  \details  Programming is done per block of max FLASH_WRITE_BLOCK_SIZE. for this a 
  87:../../../Source/ARMCM3_STM32/flash.c ****  *            flash block manager is implemented in this driver. this flash block manager
  88:../../../Source/ARMCM3_STM32/flash.c ****  *            depends on this flash block info structure. It holds the base address of 
  89:../../../Source/ARMCM3_STM32/flash.c ****  *            the flash block and the data that should be programmed into the flash 
  90:../../../Source/ARMCM3_STM32/flash.c ****  *            block. The .base_addr must be a multiple of FLASH_WRITE_BLOCK_SIZE.
  91:../../../Source/ARMCM3_STM32/flash.c ****  */
  92:../../../Source/ARMCM3_STM32/flash.c **** typedef struct
  93:../../../Source/ARMCM3_STM32/flash.c **** {
  94:../../../Source/ARMCM3_STM32/flash.c ****   blt_addr  base_addr;
  95:../../../Source/ARMCM3_STM32/flash.c ****   blt_int8u data[FLASH_WRITE_BLOCK_SIZE];
  96:../../../Source/ARMCM3_STM32/flash.c **** } tFlashBlockInfo;
  97:../../../Source/ARMCM3_STM32/flash.c **** 
  98:../../../Source/ARMCM3_STM32/flash.c **** /** \brief Flash controller register layout type.  */
  99:../../../Source/ARMCM3_STM32/flash.c **** typedef struct
 100:../../../Source/ARMCM3_STM32/flash.c **** {
 101:../../../Source/ARMCM3_STM32/flash.c ****   volatile blt_int32u ACR;                       /**< flash access control register    */     
 102:../../../Source/ARMCM3_STM32/flash.c ****   volatile blt_int32u KEYR;                      /**< FPEC key register                */
 103:../../../Source/ARMCM3_STM32/flash.c ****   volatile blt_int32u OPTKEYR;                   /**< flash OPTKEY register            */
 104:../../../Source/ARMCM3_STM32/flash.c ****   volatile blt_int32u SR;                        /**< flash status register            */
 105:../../../Source/ARMCM3_STM32/flash.c ****   volatile blt_int32u CR;                        /**< flash control register           */
 106:../../../Source/ARMCM3_STM32/flash.c ****   volatile blt_int32u AR;                        /**< flash address register           */
 107:../../../Source/ARMCM3_STM32/flash.c ****   volatile blt_int32u RESERVED;
 108:../../../Source/ARMCM3_STM32/flash.c ****   volatile blt_int32u OBR;                       /**< option byte register             */
 109:../../../Source/ARMCM3_STM32/flash.c ****   volatile blt_int32u WRPR;                      /**< write protection register        */
 110:../../../Source/ARMCM3_STM32/flash.c **** } tFlashRegs;                                         
 111:../../../Source/ARMCM3_STM32/flash.c **** 
 112:../../../Source/ARMCM3_STM32/flash.c **** 
 113:../../../Source/ARMCM3_STM32/flash.c **** /****************************************************************************************
 114:../../../Source/ARMCM3_STM32/flash.c **** * Function prototypes
 115:../../../Source/ARMCM3_STM32/flash.c **** ****************************************************************************************/
 116:../../../Source/ARMCM3_STM32/flash.c **** static blt_bool  FlashInitBlock(tFlashBlockInfo *block, blt_addr address);
 117:../../../Source/ARMCM3_STM32/flash.c **** static tFlashBlockInfo *FlashSwitchBlock(tFlashBlockInfo *block, blt_addr base_addr);
 118:../../../Source/ARMCM3_STM32/flash.c **** static blt_bool  FlashAddToBlock(tFlashBlockInfo *block, blt_addr address, 
 119:../../../Source/ARMCM3_STM32/flash.c ****                                  blt_int8u *data, blt_int32u len);
 120:../../../Source/ARMCM3_STM32/flash.c **** static blt_bool  FlashWriteBlock(tFlashBlockInfo *block);
 121:../../../Source/ARMCM3_STM32/flash.c **** static blt_bool  FlashEraseSectors(blt_int8u first_sector, blt_int8u last_sector);
 122:../../../Source/ARMCM3_STM32/flash.c **** static void      FlashUnlock(void);
 123:../../../Source/ARMCM3_STM32/flash.c **** static void      FlashLock(void);
 124:../../../Source/ARMCM3_STM32/flash.c **** static blt_int8u FlashGetSector(blt_addr address);
 125:../../../Source/ARMCM3_STM32/flash.c **** static blt_addr  FlashGetSectorBaseAddr(blt_int8u sector);
 126:../../../Source/ARMCM3_STM32/flash.c **** static blt_addr  FlashGetSectorSize(blt_int8u sector);
 127:../../../Source/ARMCM3_STM32/flash.c **** 
 128:../../../Source/ARMCM3_STM32/flash.c **** 
 129:../../../Source/ARMCM3_STM32/flash.c **** /****************************************************************************************
 130:../../../Source/ARMCM3_STM32/flash.c **** * Local constant declarations
 131:../../../Source/ARMCM3_STM32/flash.c **** ****************************************************************************************/
 132:../../../Source/ARMCM3_STM32/flash.c **** /** \brief   Array wit the layout of the flash memory.
 133:../../../Source/ARMCM3_STM32/flash.c ****  *  \details Also controls what part of the flash memory is reserved for the bootloader. 
 134:../../../Source/ARMCM3_STM32/flash.c ****  *           If the bootloader size changes, the reserved sectors for the bootloader 
 135:../../../Source/ARMCM3_STM32/flash.c ****  *           might need adjustment to make sure the bootloader doesn't get overwritten.
 136:../../../Source/ARMCM3_STM32/flash.c ****  *           The current flash layout does not reflect the minimum sector size of the
 137:../../../Source/ARMCM3_STM32/flash.c ****  *           physical flash (1 - 2kb), because this would make the table quit long and
 138:../../../Source/ARMCM3_STM32/flash.c ****  *           a waste of ROM. The minimum sector size is only really needed when erasing
 139:../../../Source/ARMCM3_STM32/flash.c ****  *           the flash. This can still be done in combination with macro 
 140:../../../Source/ARMCM3_STM32/flash.c ****  *           FLASH_ERASE_BLOCK_SIZE.
 141:../../../Source/ARMCM3_STM32/flash.c ****  */
 142:../../../Source/ARMCM3_STM32/flash.c **** static const tFlashSector flashLayout[] =
 143:../../../Source/ARMCM3_STM32/flash.c **** {
 144:../../../Source/ARMCM3_STM32/flash.c ****   /* space is reserved for a bootloader configuration with all supported communication
 145:../../../Source/ARMCM3_STM32/flash.c ****    * interfaces enabled. when for example only UART is needed, than the space required
 146:../../../Source/ARMCM3_STM32/flash.c ****    * for the bootloader can be made a lot smaller here.
 147:../../../Source/ARMCM3_STM32/flash.c ****    */
 148:../../../Source/ARMCM3_STM32/flash.c ****   /* { 0x08000000, 0x02000,  0},           flash sector  0 - reserved for bootloader   */
 149:../../../Source/ARMCM3_STM32/flash.c ****   /* { 0x08002000, 0x02000,  1},           flash sector  1 - reserved for bootloader   */
 150:../../../Source/ARMCM3_STM32/flash.c ****   /* { 0x08004000, 0x02000,  2},           flash sector  2 - reserved for bootloader   */
 151:../../../Source/ARMCM3_STM32/flash.c ****   { 0x08006000, 0x02000,  3},           /* flash sector  3 - 8kb                       */
 152:../../../Source/ARMCM3_STM32/flash.c **** #if (BOOT_NVM_SIZE_KB > 32)
 153:../../../Source/ARMCM3_STM32/flash.c ****   { 0x08008000, 0x02000,  4},           /* flash sector  4 - 8kb                       */
 154:../../../Source/ARMCM3_STM32/flash.c ****   { 0x0800A000, 0x02000,  5},           /* flash sector  5 - 8kb                       */
 155:../../../Source/ARMCM3_STM32/flash.c ****   { 0x0800C000, 0x02000,  6},           /* flash sector  6 - 8kb                       */
 156:../../../Source/ARMCM3_STM32/flash.c ****   { 0x0800E000, 0x02000,  7},           /* flash sector  7 - 8kb                       */
 157:../../../Source/ARMCM3_STM32/flash.c **** #endif
 158:../../../Source/ARMCM3_STM32/flash.c **** #if (BOOT_NVM_SIZE_KB > 64)
 159:../../../Source/ARMCM3_STM32/flash.c ****   { 0x08010000, 0x02000,  8},           /* flash sector  8 - 8kb                       */
 160:../../../Source/ARMCM3_STM32/flash.c ****   { 0x08012000, 0x02000,  9},           /* flash sector  9 - 8kb                       */
 161:../../../Source/ARMCM3_STM32/flash.c ****   { 0x08014000, 0x02000, 10},           /* flash sector 10 - 8kb                       */
 162:../../../Source/ARMCM3_STM32/flash.c ****   { 0x08016000, 0x02000, 11},           /* flash sector 11 - 8kb                       */
 163:../../../Source/ARMCM3_STM32/flash.c ****   { 0x08018000, 0x02000, 12},           /* flash sector 12 - 8kb                       */
 164:../../../Source/ARMCM3_STM32/flash.c ****   { 0x0801A000, 0x02000, 13},           /* flash sector 13 - 8kb                       */
 165:../../../Source/ARMCM3_STM32/flash.c ****   { 0x0801C000, 0x02000, 14},           /* flash sector 14 - 8kb                       */
 166:../../../Source/ARMCM3_STM32/flash.c ****   { 0x0801E000, 0x02000, 15},           /* flash sector 15 - 8kb                       */
 167:../../../Source/ARMCM3_STM32/flash.c **** #endif
 168:../../../Source/ARMCM3_STM32/flash.c **** #if (BOOT_NVM_SIZE_KB > 128)
 169:../../../Source/ARMCM3_STM32/flash.c ****   { 0x08020000, 0x08000, 16},           /* flash sector 16 - 32kb                      */
 170:../../../Source/ARMCM3_STM32/flash.c ****   { 0x08028000, 0x08000, 17},           /* flash sector 17 - 32kb                      */
 171:../../../Source/ARMCM3_STM32/flash.c ****   { 0x08030000, 0x08000, 18},           /* flash sector 18 - 32kb                      */
 172:../../../Source/ARMCM3_STM32/flash.c ****   { 0x08038000, 0x08000, 19},           /* flash sector 19 - 32kb                      */
 173:../../../Source/ARMCM3_STM32/flash.c **** #endif
 174:../../../Source/ARMCM3_STM32/flash.c **** #if (BOOT_NVM_SIZE_KB > 256)
 175:../../../Source/ARMCM3_STM32/flash.c ****   { 0x08040000, 0x08000, 20},           /* flash sector 20 - 32kb                      */
 176:../../../Source/ARMCM3_STM32/flash.c ****   { 0x08048000, 0x08000, 21},           /* flash sector 21 - 32kb                      */
 177:../../../Source/ARMCM3_STM32/flash.c ****   { 0x08050000, 0x08000, 22},           /* flash sector 22 - 32kb                      */
 178:../../../Source/ARMCM3_STM32/flash.c ****   { 0x08058000, 0x08000, 23},           /* flash sector 23 - 32kb                      */
 179:../../../Source/ARMCM3_STM32/flash.c ****   { 0x08060000, 0x08000, 24},           /* flash sector 24 - 32kb                      */
 180:../../../Source/ARMCM3_STM32/flash.c ****   { 0x08068000, 0x08000, 25},           /* flash sector 25 - 32kb                      */
 181:../../../Source/ARMCM3_STM32/flash.c ****   { 0x08070000, 0x08000, 26},           /* flash sector 26 - 32kb                      */
 182:../../../Source/ARMCM3_STM32/flash.c ****   { 0x08078000, 0x08000, 27},           /* flash sector 27 - 32kb                      */
 183:../../../Source/ARMCM3_STM32/flash.c **** #endif
 184:../../../Source/ARMCM3_STM32/flash.c **** #if (BOOT_NVM_SIZE_KB > 512)
 185:../../../Source/ARMCM3_STM32/flash.c **** #error "BOOT_NVM_SIZE_KB > 512 is currently not supported."
 186:../../../Source/ARMCM3_STM32/flash.c **** #endif
 187:../../../Source/ARMCM3_STM32/flash.c **** };
 188:../../../Source/ARMCM3_STM32/flash.c **** 
 189:../../../Source/ARMCM3_STM32/flash.c **** 
 190:../../../Source/ARMCM3_STM32/flash.c **** /****************************************************************************************
 191:../../../Source/ARMCM3_STM32/flash.c **** * Local data declarations
 192:../../../Source/ARMCM3_STM32/flash.c **** ****************************************************************************************/
 193:../../../Source/ARMCM3_STM32/flash.c **** /** \brief   Local variable with information about the flash block that is currently
 194:../../../Source/ARMCM3_STM32/flash.c ****  *           being operated on.
 195:../../../Source/ARMCM3_STM32/flash.c ****  *  \details The smallest amount of flash that can be programmed is 
 196:../../../Source/ARMCM3_STM32/flash.c ****  *           FLASH_WRITE_BLOCK_SIZE. A flash block manager is implemented in this driver
 197:../../../Source/ARMCM3_STM32/flash.c ****  *           and stores info in this variable. Whenever new data should be flashed, it
 198:../../../Source/ARMCM3_STM32/flash.c ****  *           is first added to a RAM buffer, which is part of this variable. Whenever
 199:../../../Source/ARMCM3_STM32/flash.c ****  *           the RAM buffer, which has the size of a flash block, is full or  data needs
 200:../../../Source/ARMCM3_STM32/flash.c ****  *           to be written to a different block, the contents of the RAM buffer are 
 201:../../../Source/ARMCM3_STM32/flash.c ****  *           programmed to flash. The flash block manager requires some software 
 202:../../../Source/ARMCM3_STM32/flash.c ****  *           overhead, yet results is faster flash programming because data is first 
 203:../../../Source/ARMCM3_STM32/flash.c ****  *           harvested, ideally until there is enough to program an entire flash block, 
 204:../../../Source/ARMCM3_STM32/flash.c ****  *           before the flash device is actually operated on.
 205:../../../Source/ARMCM3_STM32/flash.c ****  */
 206:../../../Source/ARMCM3_STM32/flash.c **** static tFlashBlockInfo blockInfo;
 207:../../../Source/ARMCM3_STM32/flash.c **** 
 208:../../../Source/ARMCM3_STM32/flash.c **** /** \brief   Local variable with information about the flash boot block.
 209:../../../Source/ARMCM3_STM32/flash.c ****  *  \details The first block of the user program holds the vector table, which on the 
 210:../../../Source/ARMCM3_STM32/flash.c ****  *           STM32 is also the where the checksum is written to. Is it likely that 
 211:../../../Source/ARMCM3_STM32/flash.c ****  *           the vector table is first flashed and then, at the end of the programming
 212:../../../Source/ARMCM3_STM32/flash.c ****  *           sequence, the checksum. This means that this flash block need to be written
 213:../../../Source/ARMCM3_STM32/flash.c ****  *           to twice. Normally this is not a problem with flash memory, as long as you
 214:../../../Source/ARMCM3_STM32/flash.c ****  *           write the same values to those bytes that are not supposed to be changed 
 215:../../../Source/ARMCM3_STM32/flash.c ****  *           and the locations where you do write to are still in the erased 0xFF state.
 216:../../../Source/ARMCM3_STM32/flash.c ****  *           Unfortunately, writing twice to flash this way, does not work reliably on 
 217:../../../Source/ARMCM3_STM32/flash.c ****  *           all micros. This is why we need to have an extra block, the bootblock,
 218:../../../Source/ARMCM3_STM32/flash.c ****  *           placed under the management of the block manager. This way is it possible 
 219:../../../Source/ARMCM3_STM32/flash.c ****  *           to implement functionality so that the bootblock is only written to once
 220:../../../Source/ARMCM3_STM32/flash.c ****  *           at the end of the programming sequence.
 221:../../../Source/ARMCM3_STM32/flash.c ****  */
 222:../../../Source/ARMCM3_STM32/flash.c **** static tFlashBlockInfo bootBlockInfo;
 223:../../../Source/ARMCM3_STM32/flash.c **** 
 224:../../../Source/ARMCM3_STM32/flash.c **** 
 225:../../../Source/ARMCM3_STM32/flash.c **** /************************************************************************************//**
 226:../../../Source/ARMCM3_STM32/flash.c **** ** \brief     Initializes the flash driver. 
 227:../../../Source/ARMCM3_STM32/flash.c **** ** \return    none.
 228:../../../Source/ARMCM3_STM32/flash.c **** **
 229:../../../Source/ARMCM3_STM32/flash.c **** ****************************************************************************************/
 230:../../../Source/ARMCM3_STM32/flash.c **** void FlashInit(void)
 231:../../../Source/ARMCM3_STM32/flash.c **** {
 232:../../../Source/ARMCM3_STM32/flash.c ****   /* init the flash block info structs by setting the address to an invalid address */
 233:../../../Source/ARMCM3_STM32/flash.c ****   blockInfo.base_addr = FLASH_INVALID_ADDRESS;
 234:../../../Source/ARMCM3_STM32/flash.c ****   bootBlockInfo.base_addr = FLASH_INVALID_ADDRESS;
 235:../../../Source/ARMCM3_STM32/flash.c **** } /*** end of FlashInit ***/
 236:../../../Source/ARMCM3_STM32/flash.c **** 
 237:../../../Source/ARMCM3_STM32/flash.c **** 
 238:../../../Source/ARMCM3_STM32/flash.c **** /************************************************************************************//**
 239:../../../Source/ARMCM3_STM32/flash.c **** ** \brief     Writes the data to flash through a flash block manager. Note that this
 240:../../../Source/ARMCM3_STM32/flash.c **** **            function also checks that no data is programmed outside the flash 
 241:../../../Source/ARMCM3_STM32/flash.c **** **            memory region, so the bootloader can never be overwritten.
 242:../../../Source/ARMCM3_STM32/flash.c **** ** \param     addr Start address.
 243:../../../Source/ARMCM3_STM32/flash.c **** ** \param     len  Length in bytes.
 244:../../../Source/ARMCM3_STM32/flash.c **** ** \param     data Pointer to the data buffer.
 245:../../../Source/ARMCM3_STM32/flash.c **** ** \return    BLT_TRUE if successful, BLT_FALSE otherwise. 
 246:../../../Source/ARMCM3_STM32/flash.c **** **
 247:../../../Source/ARMCM3_STM32/flash.c **** ****************************************************************************************/
 248:../../../Source/ARMCM3_STM32/flash.c **** blt_bool FlashWrite(blt_addr addr, blt_int32u len, blt_int8u *data)
 249:../../../Source/ARMCM3_STM32/flash.c **** {
 250:../../../Source/ARMCM3_STM32/flash.c ****   blt_addr base_addr;
 251:../../../Source/ARMCM3_STM32/flash.c **** 
 252:../../../Source/ARMCM3_STM32/flash.c ****   /* make sure the addresses are within the flash device */
 253:../../../Source/ARMCM3_STM32/flash.c ****   if ( (FlashGetSector(addr) == FLASH_INVALID_SECTOR) || \
 254:../../../Source/ARMCM3_STM32/flash.c ****        (FlashGetSector(addr+len-1) == FLASH_INVALID_SECTOR) )
 255:../../../Source/ARMCM3_STM32/flash.c ****   {
 256:../../../Source/ARMCM3_STM32/flash.c ****     return BLT_FALSE;       
 257:../../../Source/ARMCM3_STM32/flash.c ****   }
 258:../../../Source/ARMCM3_STM32/flash.c **** 
 259:../../../Source/ARMCM3_STM32/flash.c ****   /* if this is the bootblock, then let the boot block manager handle it */
 260:../../../Source/ARMCM3_STM32/flash.c ****   base_addr = (addr/FLASH_WRITE_BLOCK_SIZE)*FLASH_WRITE_BLOCK_SIZE;
 261:../../../Source/ARMCM3_STM32/flash.c ****   if (base_addr == flashLayout[0].sector_start)
 262:../../../Source/ARMCM3_STM32/flash.c ****   {
 263:../../../Source/ARMCM3_STM32/flash.c ****     /* let the boot block manager handle it */
 264:../../../Source/ARMCM3_STM32/flash.c ****     return FlashAddToBlock(&bootBlockInfo, addr, data, len);
 265:../../../Source/ARMCM3_STM32/flash.c ****   }
 266:../../../Source/ARMCM3_STM32/flash.c ****   /* let the block manager handle it */
 267:../../../Source/ARMCM3_STM32/flash.c ****   return FlashAddToBlock(&blockInfo, addr, data, len);
 268:../../../Source/ARMCM3_STM32/flash.c **** } /*** end of FlashWrite ***/
 269:../../../Source/ARMCM3_STM32/flash.c **** 
 270:../../../Source/ARMCM3_STM32/flash.c **** 
 271:../../../Source/ARMCM3_STM32/flash.c **** /************************************************************************************//**
 272:../../../Source/ARMCM3_STM32/flash.c **** ** \brief     Erases the flash memory. Note that this function also checks that no 
 273:../../../Source/ARMCM3_STM32/flash.c **** **            data is erased outside the flash memory region, so the bootloader can 
 274:../../../Source/ARMCM3_STM32/flash.c **** **            never be erased.
 275:../../../Source/ARMCM3_STM32/flash.c **** ** \param     addr Start address.
 276:../../../Source/ARMCM3_STM32/flash.c **** ** \param     len  Length in bytes.
 277:../../../Source/ARMCM3_STM32/flash.c **** ** \return    BLT_TRUE if successful, BLT_FALSE otherwise. 
 278:../../../Source/ARMCM3_STM32/flash.c **** **
 279:../../../Source/ARMCM3_STM32/flash.c **** ****************************************************************************************/
 280:../../../Source/ARMCM3_STM32/flash.c **** blt_bool FlashErase(blt_addr addr, blt_int32u len)
 281:../../../Source/ARMCM3_STM32/flash.c **** {
 282:../../../Source/ARMCM3_STM32/flash.c ****   blt_int8u first_sector;
 283:../../../Source/ARMCM3_STM32/flash.c ****   blt_int8u last_sector;
 284:../../../Source/ARMCM3_STM32/flash.c ****   
 285:../../../Source/ARMCM3_STM32/flash.c ****   /* obtain the first and last sector number */
 286:../../../Source/ARMCM3_STM32/flash.c ****   first_sector = FlashGetSector(addr);
 287:../../../Source/ARMCM3_STM32/flash.c ****   last_sector  = FlashGetSector(addr+len-1);
 288:../../../Source/ARMCM3_STM32/flash.c ****   /* check them */
 289:../../../Source/ARMCM3_STM32/flash.c ****   if ( (first_sector == FLASH_INVALID_SECTOR) || (last_sector == FLASH_INVALID_SECTOR) )
 290:../../../Source/ARMCM3_STM32/flash.c ****   {
 291:../../../Source/ARMCM3_STM32/flash.c ****     return BLT_FALSE;
 292:../../../Source/ARMCM3_STM32/flash.c ****   }
 293:../../../Source/ARMCM3_STM32/flash.c ****   /* erase the sectors */
 294:../../../Source/ARMCM3_STM32/flash.c ****   return FlashEraseSectors(first_sector, last_sector);
 295:../../../Source/ARMCM3_STM32/flash.c **** } /*** end of FlashErase ***/
 296:../../../Source/ARMCM3_STM32/flash.c **** 
 297:../../../Source/ARMCM3_STM32/flash.c **** 
 298:../../../Source/ARMCM3_STM32/flash.c **** /************************************************************************************//**
 299:../../../Source/ARMCM3_STM32/flash.c **** ** \brief     Writes a checksum of the user program to non-volatile memory. This is
 300:../../../Source/ARMCM3_STM32/flash.c **** **            performed once the entire user program has been programmed. Through
 301:../../../Source/ARMCM3_STM32/flash.c **** **            the checksum, the bootloader can check if the programming session
 302:../../../Source/ARMCM3_STM32/flash.c **** **            was completed, which indicates that a valid user programming is
 303:../../../Source/ARMCM3_STM32/flash.c **** **            present and can be started.
 304:../../../Source/ARMCM3_STM32/flash.c **** ** \return    BLT_TRUE if successful, BLT_FALSE otherwise. 
 305:../../../Source/ARMCM3_STM32/flash.c **** **
 306:../../../Source/ARMCM3_STM32/flash.c **** ****************************************************************************************/
 307:../../../Source/ARMCM3_STM32/flash.c **** blt_bool FlashWriteChecksum(void)
 308:../../../Source/ARMCM3_STM32/flash.c **** {
 309:../../../Source/ARMCM3_STM32/flash.c ****   blt_int32u signature_checksum = 0;
 310:../../../Source/ARMCM3_STM32/flash.c ****   
 311:../../../Source/ARMCM3_STM32/flash.c ****   /* for the STM32 target we defined the checksum as the Two's complement value of the
 312:../../../Source/ARMCM3_STM32/flash.c ****    * sum of the first 7 exception addresses.
 313:../../../Source/ARMCM3_STM32/flash.c ****    *
 314:../../../Source/ARMCM3_STM32/flash.c ****    * Layout of the vector table:
 315:../../../Source/ARMCM3_STM32/flash.c ****    *    0x08000000 Initial stack pointer 
 316:../../../Source/ARMCM3_STM32/flash.c ****    *    0x08000004 Reset Handler
 317:../../../Source/ARMCM3_STM32/flash.c ****    *    0x08000008 NMI Handler
 318:../../../Source/ARMCM3_STM32/flash.c ****    *    0x0800000C Hard Fault Handler
 319:../../../Source/ARMCM3_STM32/flash.c ****    *    0x08000010 MPU Fault Handler 
 320:../../../Source/ARMCM3_STM32/flash.c ****    *    0x08000014 Bus Fault Handler
 321:../../../Source/ARMCM3_STM32/flash.c ****    *    0x08000018 Usage Fault Handler
 322:../../../Source/ARMCM3_STM32/flash.c ****    *
 323:../../../Source/ARMCM3_STM32/flash.c ****    *    signature_checksum = Two's complement of (SUM(exception address values))
 324:../../../Source/ARMCM3_STM32/flash.c ****    *   
 325:../../../Source/ARMCM3_STM32/flash.c ****    *    the bootloader writes this 32-bit checksum value right after the vector table
 326:../../../Source/ARMCM3_STM32/flash.c ****    *    of the user program. note that this means one extra dummy entry must be added
 327:../../../Source/ARMCM3_STM32/flash.c ****    *    at the end of the user program's vector table to reserve storage space for the
 328:../../../Source/ARMCM3_STM32/flash.c ****    *    checksum.
 329:../../../Source/ARMCM3_STM32/flash.c ****    */
 330:../../../Source/ARMCM3_STM32/flash.c **** 
 331:../../../Source/ARMCM3_STM32/flash.c ****   /* first check that the bootblock contains valid data. if not, this means the
 332:../../../Source/ARMCM3_STM32/flash.c ****    * bootblock is not part of the reprogramming this time and therefore no
 333:../../../Source/ARMCM3_STM32/flash.c ****    * new checksum needs to be written
 334:../../../Source/ARMCM3_STM32/flash.c ****    */
 335:../../../Source/ARMCM3_STM32/flash.c ****    if (bootBlockInfo.base_addr == FLASH_INVALID_ADDRESS)
 336:../../../Source/ARMCM3_STM32/flash.c ****    {
 337:../../../Source/ARMCM3_STM32/flash.c ****     return BLT_TRUE;
 338:../../../Source/ARMCM3_STM32/flash.c ****    }
 339:../../../Source/ARMCM3_STM32/flash.c **** 
 340:../../../Source/ARMCM3_STM32/flash.c ****   /* compute the checksum. note that the user program's vectors are not yet written
 341:../../../Source/ARMCM3_STM32/flash.c ****    * to flash but are present in the bootblock data structure at this point.
 342:../../../Source/ARMCM3_STM32/flash.c ****    */
 343:../../../Source/ARMCM3_STM32/flash.c ****   signature_checksum += *((blt_int32u*)(&bootBlockInfo.data[0+0x00]));
 344:../../../Source/ARMCM3_STM32/flash.c ****   signature_checksum += *((blt_int32u*)(&bootBlockInfo.data[0+0x04]));
 345:../../../Source/ARMCM3_STM32/flash.c ****   signature_checksum += *((blt_int32u*)(&bootBlockInfo.data[0+0x08]));
 346:../../../Source/ARMCM3_STM32/flash.c ****   signature_checksum += *((blt_int32u*)(&bootBlockInfo.data[0+0x0C]));
 347:../../../Source/ARMCM3_STM32/flash.c ****   signature_checksum += *((blt_int32u*)(&bootBlockInfo.data[0+0x10]));
 348:../../../Source/ARMCM3_STM32/flash.c ****   signature_checksum += *((blt_int32u*)(&bootBlockInfo.data[0+0x14]));
 349:../../../Source/ARMCM3_STM32/flash.c ****   signature_checksum += *((blt_int32u*)(&bootBlockInfo.data[0+0x18]));
 350:../../../Source/ARMCM3_STM32/flash.c ****   signature_checksum  = ~signature_checksum; /* one's complement */
 351:../../../Source/ARMCM3_STM32/flash.c ****   signature_checksum += 1; /* two's complement */
 352:../../../Source/ARMCM3_STM32/flash.c **** 
 353:../../../Source/ARMCM3_STM32/flash.c ****   /* write the checksum */
 354:../../../Source/ARMCM3_STM32/flash.c ****   return FlashWrite(flashLayout[0].sector_start+FLASH_VECTOR_TABLE_CS_OFFSET, 
 355:../../../Source/ARMCM3_STM32/flash.c ****                     sizeof(blt_addr), (blt_int8u*)&signature_checksum);
 356:../../../Source/ARMCM3_STM32/flash.c **** } /*** end of FlashWriteChecksum ***/
 357:../../../Source/ARMCM3_STM32/flash.c **** 
 358:../../../Source/ARMCM3_STM32/flash.c **** 
 359:../../../Source/ARMCM3_STM32/flash.c **** /************************************************************************************//**
 360:../../../Source/ARMCM3_STM32/flash.c **** ** \brief     Verifies the checksum, which indicates that a valid user program is
 361:../../../Source/ARMCM3_STM32/flash.c **** **            present and can be started.
 362:../../../Source/ARMCM3_STM32/flash.c **** ** \return    BLT_TRUE if successful, BLT_FALSE otherwise. 
 363:../../../Source/ARMCM3_STM32/flash.c **** **
 364:../../../Source/ARMCM3_STM32/flash.c **** ****************************************************************************************/
 365:../../../Source/ARMCM3_STM32/flash.c **** blt_bool FlashVerifyChecksum(void)
 366:../../../Source/ARMCM3_STM32/flash.c **** {
 367:../../../Source/ARMCM3_STM32/flash.c ****   blt_int32u signature_checksum = 0;
 368:../../../Source/ARMCM3_STM32/flash.c ****   
 369:../../../Source/ARMCM3_STM32/flash.c ****   /* verify the checksum based on how it was written by CpuWriteChecksum() */
 370:../../../Source/ARMCM3_STM32/flash.c ****   signature_checksum += *((blt_int32u*)(flashLayout[0].sector_start));
 371:../../../Source/ARMCM3_STM32/flash.c ****   signature_checksum += *((blt_int32u*)(flashLayout[0].sector_start+0x04));
 372:../../../Source/ARMCM3_STM32/flash.c ****   signature_checksum += *((blt_int32u*)(flashLayout[0].sector_start+0x08));
 373:../../../Source/ARMCM3_STM32/flash.c ****   signature_checksum += *((blt_int32u*)(flashLayout[0].sector_start+0x0C));
 374:../../../Source/ARMCM3_STM32/flash.c ****   signature_checksum += *((blt_int32u*)(flashLayout[0].sector_start+0x10));
 375:../../../Source/ARMCM3_STM32/flash.c ****   signature_checksum += *((blt_int32u*)(flashLayout[0].sector_start+0x14));
 376:../../../Source/ARMCM3_STM32/flash.c ****   signature_checksum += *((blt_int32u*)(flashLayout[0].sector_start+0x18));
 377:../../../Source/ARMCM3_STM32/flash.c ****   signature_checksum += *((blt_int32u*)(flashLayout[0].sector_start+FLASH_VECTOR_TABLE_CS_OFFSET));
 378:../../../Source/ARMCM3_STM32/flash.c ****   /* sum should add up to an unsigned 32-bit value of 0 */
 379:../../../Source/ARMCM3_STM32/flash.c ****   if (signature_checksum == 0)
 380:../../../Source/ARMCM3_STM32/flash.c ****   {
 381:../../../Source/ARMCM3_STM32/flash.c ****     /* checksum okay */
 382:../../../Source/ARMCM3_STM32/flash.c ****     return BLT_TRUE;
 383:../../../Source/ARMCM3_STM32/flash.c ****   }
 384:../../../Source/ARMCM3_STM32/flash.c ****   /* checksum incorrect */
 385:../../../Source/ARMCM3_STM32/flash.c ****   return BLT_FALSE;
 386:../../../Source/ARMCM3_STM32/flash.c **** } /*** end of FlashVerifyChecksum ***/
 387:../../../Source/ARMCM3_STM32/flash.c **** 
 388:../../../Source/ARMCM3_STM32/flash.c **** 
 389:../../../Source/ARMCM3_STM32/flash.c **** /************************************************************************************//**
 390:../../../Source/ARMCM3_STM32/flash.c **** ** \brief     Finalizes the flash driver operations. There could still be data in
 391:../../../Source/ARMCM3_STM32/flash.c **** **            the currently active block that needs to be flashed.
 392:../../../Source/ARMCM3_STM32/flash.c **** ** \return    BLT_TRUE if successful, BLT_FALSE otherwise. 
 393:../../../Source/ARMCM3_STM32/flash.c **** **
 394:../../../Source/ARMCM3_STM32/flash.c **** ****************************************************************************************/
 395:../../../Source/ARMCM3_STM32/flash.c **** blt_bool FlashDone(void)
 396:../../../Source/ARMCM3_STM32/flash.c **** {
 397:../../../Source/ARMCM3_STM32/flash.c ****   /* check if there is still data waiting to be programmed in the boot block */
 398:../../../Source/ARMCM3_STM32/flash.c ****   if (bootBlockInfo.base_addr != FLASH_INVALID_ADDRESS)
 399:../../../Source/ARMCM3_STM32/flash.c ****   {
 400:../../../Source/ARMCM3_STM32/flash.c ****     if (FlashWriteBlock(&bootBlockInfo) == BLT_FALSE)
 401:../../../Source/ARMCM3_STM32/flash.c ****     {
 402:../../../Source/ARMCM3_STM32/flash.c ****       return BLT_FALSE;
 403:../../../Source/ARMCM3_STM32/flash.c ****     }
 404:../../../Source/ARMCM3_STM32/flash.c ****   }
 405:../../../Source/ARMCM3_STM32/flash.c ****   
 406:../../../Source/ARMCM3_STM32/flash.c ****   /* check if there is still data waiting to be programmed */
 407:../../../Source/ARMCM3_STM32/flash.c ****   if (blockInfo.base_addr != FLASH_INVALID_ADDRESS)
 408:../../../Source/ARMCM3_STM32/flash.c ****   {
 409:../../../Source/ARMCM3_STM32/flash.c ****     if (FlashWriteBlock(&blockInfo) == BLT_FALSE)
 410:../../../Source/ARMCM3_STM32/flash.c ****     {
 411:../../../Source/ARMCM3_STM32/flash.c ****       return BLT_FALSE;
 412:../../../Source/ARMCM3_STM32/flash.c ****     }
 413:../../../Source/ARMCM3_STM32/flash.c ****   }
 414:../../../Source/ARMCM3_STM32/flash.c ****   /* still here so all is okay */  
 415:../../../Source/ARMCM3_STM32/flash.c ****   return BLT_TRUE;
 416:../../../Source/ARMCM3_STM32/flash.c **** } /*** end of FlashDone ***/
 417:../../../Source/ARMCM3_STM32/flash.c **** 
 418:../../../Source/ARMCM3_STM32/flash.c **** 
 419:../../../Source/ARMCM3_STM32/flash.c **** /************************************************************************************//**
 420:../../../Source/ARMCM3_STM32/flash.c **** ** \brief     Obtains the base address of the flash memory available to the user program.
 421:../../../Source/ARMCM3_STM32/flash.c **** **            This is basically the first address in the flashLayout table.
 422:../../../Source/ARMCM3_STM32/flash.c **** ** \return    Base address.
 423:../../../Source/ARMCM3_STM32/flash.c **** **
 424:../../../Source/ARMCM3_STM32/flash.c **** ****************************************************************************************/
 425:../../../Source/ARMCM3_STM32/flash.c **** blt_addr FlashGetUserProgBaseAddress(void)
 426:../../../Source/ARMCM3_STM32/flash.c **** {
 427:../../../Source/ARMCM3_STM32/flash.c ****   return flashLayout[0].sector_start;
 428:../../../Source/ARMCM3_STM32/flash.c **** } /*** end of FlashGetUserProgBaseAddress ***/
 429:../../../Source/ARMCM3_STM32/flash.c **** 
 430:../../../Source/ARMCM3_STM32/flash.c **** 
 431:../../../Source/ARMCM3_STM32/flash.c **** /************************************************************************************//**
 432:../../../Source/ARMCM3_STM32/flash.c **** ** \brief     Copies data currently in flash to the block->data and sets the 
 433:../../../Source/ARMCM3_STM32/flash.c **** **            base address.
 434:../../../Source/ARMCM3_STM32/flash.c **** ** \param     block   Pointer to flash block info structure to operate on.
 435:../../../Source/ARMCM3_STM32/flash.c **** ** \param     address Base address of the block data.
 436:../../../Source/ARMCM3_STM32/flash.c **** ** \return    BLT_TRUE if successful, BLT_FALSE otherwise. 
 437:../../../Source/ARMCM3_STM32/flash.c **** **
 438:../../../Source/ARMCM3_STM32/flash.c **** ****************************************************************************************/
 439:../../../Source/ARMCM3_STM32/flash.c **** static blt_bool FlashInitBlock(tFlashBlockInfo *block, blt_addr address)
 440:../../../Source/ARMCM3_STM32/flash.c **** {
 441:../../../Source/ARMCM3_STM32/flash.c ****   /* check address alignment */  
 442:../../../Source/ARMCM3_STM32/flash.c ****   if ((address % FLASH_WRITE_BLOCK_SIZE) != 0)
 443:../../../Source/ARMCM3_STM32/flash.c ****   {
 444:../../../Source/ARMCM3_STM32/flash.c ****     return BLT_FALSE;
 445:../../../Source/ARMCM3_STM32/flash.c ****   }
 446:../../../Source/ARMCM3_STM32/flash.c ****   /* make sure that we are initializing a new block and not the same one */
 447:../../../Source/ARMCM3_STM32/flash.c ****   if (block->base_addr == address)
 448:../../../Source/ARMCM3_STM32/flash.c ****   {
 449:../../../Source/ARMCM3_STM32/flash.c ****     /* block already initialized, so nothing to do */
 450:../../../Source/ARMCM3_STM32/flash.c ****     return BLT_TRUE;
 451:../../../Source/ARMCM3_STM32/flash.c ****   }
 452:../../../Source/ARMCM3_STM32/flash.c ****   /* set the base address and copies the current data from flash */  
 453:../../../Source/ARMCM3_STM32/flash.c ****   block->base_addr = address;  
 454:../../../Source/ARMCM3_STM32/flash.c ****   CpuMemCopy((blt_addr)block->data, address, FLASH_WRITE_BLOCK_SIZE);
 455:../../../Source/ARMCM3_STM32/flash.c ****   return BLT_TRUE;
 456:../../../Source/ARMCM3_STM32/flash.c **** } /*** end of FlashInitBlock ***/
 457:../../../Source/ARMCM3_STM32/flash.c **** 
 458:../../../Source/ARMCM3_STM32/flash.c **** 
 459:../../../Source/ARMCM3_STM32/flash.c **** /************************************************************************************//**
 460:../../../Source/ARMCM3_STM32/flash.c **** ** \brief     Switches blocks by programming the current one and initializing the
 461:../../../Source/ARMCM3_STM32/flash.c **** **            next.
 462:../../../Source/ARMCM3_STM32/flash.c **** ** \param     block   Pointer to flash block info structure to operate on.
 463:../../../Source/ARMCM3_STM32/flash.c **** ** \param     base_addr Base address of the next block.
 464:../../../Source/ARMCM3_STM32/flash.c **** ** \return    The pointer of the block info struct that is no being used, or a NULL
 465:../../../Source/ARMCM3_STM32/flash.c **** **            pointer in case of error.
 466:../../../Source/ARMCM3_STM32/flash.c **** **
 467:../../../Source/ARMCM3_STM32/flash.c **** ****************************************************************************************/
 468:../../../Source/ARMCM3_STM32/flash.c **** static tFlashBlockInfo *FlashSwitchBlock(tFlashBlockInfo *block, blt_addr base_addr)
 469:../../../Source/ARMCM3_STM32/flash.c **** {
 470:../../../Source/ARMCM3_STM32/flash.c ****   /* check if a switch needs to be made away from the boot block. in this case the boot
 471:../../../Source/ARMCM3_STM32/flash.c ****    * block shouldn't be written yet, because this is done at the end of the programming
 472:../../../Source/ARMCM3_STM32/flash.c ****    * session by FlashDone(), this is right after the checksum was written. 
 473:../../../Source/ARMCM3_STM32/flash.c ****    */
 474:../../../Source/ARMCM3_STM32/flash.c ****   if (block == &bootBlockInfo)
 475:../../../Source/ARMCM3_STM32/flash.c ****   {
 476:../../../Source/ARMCM3_STM32/flash.c ****     /* switch from the boot block to the generic block info structure */
 477:../../../Source/ARMCM3_STM32/flash.c ****     block = &blockInfo;
 478:../../../Source/ARMCM3_STM32/flash.c ****   }
 479:../../../Source/ARMCM3_STM32/flash.c ****   /* check if a switch back into the bootblock is needed. in this case the generic block 
 480:../../../Source/ARMCM3_STM32/flash.c ****    * doesn't need to be written here yet.
 481:../../../Source/ARMCM3_STM32/flash.c ****    */
 482:../../../Source/ARMCM3_STM32/flash.c ****   else if (base_addr == flashLayout[0].sector_start)
 483:../../../Source/ARMCM3_STM32/flash.c ****   {
 484:../../../Source/ARMCM3_STM32/flash.c ****     /* switch from the generic block to the boot block info structure */
 485:../../../Source/ARMCM3_STM32/flash.c ****     block = &bootBlockInfo;
 486:../../../Source/ARMCM3_STM32/flash.c ****     base_addr = flashLayout[0].sector_start;
 487:../../../Source/ARMCM3_STM32/flash.c ****   }
 488:../../../Source/ARMCM3_STM32/flash.c ****   else
 489:../../../Source/ARMCM3_STM32/flash.c ****   {
 490:../../../Source/ARMCM3_STM32/flash.c ****     /* need to switch to a new block, so program the current one and init the next */
 491:../../../Source/ARMCM3_STM32/flash.c ****     if (FlashWriteBlock(block) == BLT_FALSE)
 492:../../../Source/ARMCM3_STM32/flash.c ****     {
 493:../../../Source/ARMCM3_STM32/flash.c ****       return BLT_NULL;
 494:../../../Source/ARMCM3_STM32/flash.c ****     }
 495:../../../Source/ARMCM3_STM32/flash.c ****   }
 496:../../../Source/ARMCM3_STM32/flash.c **** 
 497:../../../Source/ARMCM3_STM32/flash.c ****   /* initialize tne new block when necessary */
 498:../../../Source/ARMCM3_STM32/flash.c ****   if (FlashInitBlock(block, base_addr) == BLT_FALSE) 
 499:../../../Source/ARMCM3_STM32/flash.c ****   {
 500:../../../Source/ARMCM3_STM32/flash.c ****     return BLT_NULL;
 501:../../../Source/ARMCM3_STM32/flash.c ****   }
 502:../../../Source/ARMCM3_STM32/flash.c **** 
 503:../../../Source/ARMCM3_STM32/flash.c ****   /* still here to all is okay  */
 504:../../../Source/ARMCM3_STM32/flash.c ****   return block;
 505:../../../Source/ARMCM3_STM32/flash.c **** } /*** end of FlashSwitchBlock ***/
 506:../../../Source/ARMCM3_STM32/flash.c **** 
 507:../../../Source/ARMCM3_STM32/flash.c **** 
 508:../../../Source/ARMCM3_STM32/flash.c **** /************************************************************************************//**
 509:../../../Source/ARMCM3_STM32/flash.c **** ** \brief     Programming is done per block. This function adds data to the block
 510:../../../Source/ARMCM3_STM32/flash.c **** **            that is currently collecting data to be written to flash. If the
 511:../../../Source/ARMCM3_STM32/flash.c **** **            address is outside of the current block, the current block is written
 512:../../../Source/ARMCM3_STM32/flash.c **** **            to flash an a new block is initialized.
 513:../../../Source/ARMCM3_STM32/flash.c **** ** \param     block   Pointer to flash block info structure to operate on.
 514:../../../Source/ARMCM3_STM32/flash.c **** ** \param     address Flash destination address.
 515:../../../Source/ARMCM3_STM32/flash.c **** ** \param     data    Pointer to the byte array with data.
 516:../../../Source/ARMCM3_STM32/flash.c **** ** \param     len     Number of bytes to add to the block.
 517:../../../Source/ARMCM3_STM32/flash.c **** ** \return    BLT_TRUE if successful, BLT_FALSE otherwise.
 518:../../../Source/ARMCM3_STM32/flash.c **** **
 519:../../../Source/ARMCM3_STM32/flash.c **** ****************************************************************************************/
 520:../../../Source/ARMCM3_STM32/flash.c **** static blt_bool FlashAddToBlock(tFlashBlockInfo *block, blt_addr address, 
 521:../../../Source/ARMCM3_STM32/flash.c ****                                 blt_int8u *data, blt_int32u len)
 522:../../../Source/ARMCM3_STM32/flash.c **** {
 523:../../../Source/ARMCM3_STM32/flash.c ****   blt_addr   current_base_addr;
 524:../../../Source/ARMCM3_STM32/flash.c ****   blt_int8u  *dst;
 525:../../../Source/ARMCM3_STM32/flash.c ****   blt_int8u  *src;
 526:../../../Source/ARMCM3_STM32/flash.c ****   
 527:../../../Source/ARMCM3_STM32/flash.c ****   /* determine the current base address */
 528:../../../Source/ARMCM3_STM32/flash.c ****   current_base_addr = (address/FLASH_WRITE_BLOCK_SIZE)*FLASH_WRITE_BLOCK_SIZE;
 529:../../../Source/ARMCM3_STM32/flash.c **** 
 530:../../../Source/ARMCM3_STM32/flash.c ****   /* make sure the blockInfo is not uninitialized */
 531:../../../Source/ARMCM3_STM32/flash.c ****   if (block->base_addr == FLASH_INVALID_ADDRESS)
 532:../../../Source/ARMCM3_STM32/flash.c ****   {
 533:../../../Source/ARMCM3_STM32/flash.c ****     /* initialize the blockInfo struct for the current block */
 534:../../../Source/ARMCM3_STM32/flash.c ****     if (FlashInitBlock(block, current_base_addr) == BLT_FALSE)
 535:../../../Source/ARMCM3_STM32/flash.c ****     {
 536:../../../Source/ARMCM3_STM32/flash.c ****       return BLT_FALSE;
 537:../../../Source/ARMCM3_STM32/flash.c ****     }
 538:../../../Source/ARMCM3_STM32/flash.c ****   }
 539:../../../Source/ARMCM3_STM32/flash.c **** 
 540:../../../Source/ARMCM3_STM32/flash.c ****   /* check if the new data fits in the current block */
 541:../../../Source/ARMCM3_STM32/flash.c ****   if (block->base_addr != current_base_addr)
 542:../../../Source/ARMCM3_STM32/flash.c ****   {
 543:../../../Source/ARMCM3_STM32/flash.c ****     /* need to switch to a new block, so program the current one and init the next */
 544:../../../Source/ARMCM3_STM32/flash.c ****     block = FlashSwitchBlock(block, current_base_addr);
 545:../../../Source/ARMCM3_STM32/flash.c ****     if (block == BLT_NULL)
 546:../../../Source/ARMCM3_STM32/flash.c ****     {
 547:../../../Source/ARMCM3_STM32/flash.c ****       return BLT_FALSE;
 548:../../../Source/ARMCM3_STM32/flash.c ****     }
 549:../../../Source/ARMCM3_STM32/flash.c ****   }
 550:../../../Source/ARMCM3_STM32/flash.c ****   
 551:../../../Source/ARMCM3_STM32/flash.c ****   /* add the data to the current block, but check for block overflow */
 552:../../../Source/ARMCM3_STM32/flash.c ****   dst = &(block->data[address - block->base_addr]);
 553:../../../Source/ARMCM3_STM32/flash.c ****   src = data;
 554:../../../Source/ARMCM3_STM32/flash.c ****   do
 555:../../../Source/ARMCM3_STM32/flash.c ****   {
 556:../../../Source/ARMCM3_STM32/flash.c ****     /* keep the watchdog happy */
 557:../../../Source/ARMCM3_STM32/flash.c ****     CopService();
 558:../../../Source/ARMCM3_STM32/flash.c ****     /* buffer overflow? */
 559:../../../Source/ARMCM3_STM32/flash.c ****     if ((blt_addr)(dst-&(block->data[0])) >= FLASH_WRITE_BLOCK_SIZE)
 560:../../../Source/ARMCM3_STM32/flash.c ****     {
 561:../../../Source/ARMCM3_STM32/flash.c ****       /* need to switch to a new block, so program the current one and init the next */
 562:../../../Source/ARMCM3_STM32/flash.c ****       block = FlashSwitchBlock(block, current_base_addr+FLASH_WRITE_BLOCK_SIZE);
 563:../../../Source/ARMCM3_STM32/flash.c ****       if (block == BLT_NULL)
 564:../../../Source/ARMCM3_STM32/flash.c ****       {
 565:../../../Source/ARMCM3_STM32/flash.c ****         return BLT_FALSE;
 566:../../../Source/ARMCM3_STM32/flash.c ****       }
 567:../../../Source/ARMCM3_STM32/flash.c ****       /* reset destination pointer */
 568:../../../Source/ARMCM3_STM32/flash.c ****       dst = &(block->data[0]);
 569:../../../Source/ARMCM3_STM32/flash.c ****     }
 570:../../../Source/ARMCM3_STM32/flash.c ****     /* write the data to the buffer */
 571:../../../Source/ARMCM3_STM32/flash.c ****     *dst = *src;
 572:../../../Source/ARMCM3_STM32/flash.c ****     /* update pointers */
 573:../../../Source/ARMCM3_STM32/flash.c ****     dst++;
 574:../../../Source/ARMCM3_STM32/flash.c ****     src++;
 575:../../../Source/ARMCM3_STM32/flash.c ****     /* decrement byte counter */
 576:../../../Source/ARMCM3_STM32/flash.c ****     len--;
 577:../../../Source/ARMCM3_STM32/flash.c ****   }
 578:../../../Source/ARMCM3_STM32/flash.c ****   while (len > 0);
 579:../../../Source/ARMCM3_STM32/flash.c ****   /* still here so all is good */
 580:../../../Source/ARMCM3_STM32/flash.c ****   return BLT_TRUE;
 581:../../../Source/ARMCM3_STM32/flash.c **** } /*** end of FlashAddToBlock ***/
 582:../../../Source/ARMCM3_STM32/flash.c **** 
 583:../../../Source/ARMCM3_STM32/flash.c **** 
 584:../../../Source/ARMCM3_STM32/flash.c **** /************************************************************************************//**
 585:../../../Source/ARMCM3_STM32/flash.c **** ** \brief     Programs FLASH_WRITE_BLOCK_SIZE bytes to flash from the block->data
 586:../../../Source/ARMCM3_STM32/flash.c **** **            array.
 587:../../../Source/ARMCM3_STM32/flash.c **** ** \param     block   Pointer to flash block info structure to operate on.
 588:../../../Source/ARMCM3_STM32/flash.c **** ** \return    BLT_TRUE if successful, BLT_FALSE otherwise.
 589:../../../Source/ARMCM3_STM32/flash.c **** **
 590:../../../Source/ARMCM3_STM32/flash.c **** ****************************************************************************************/
 591:../../../Source/ARMCM3_STM32/flash.c **** static blt_bool FlashWriteBlock(tFlashBlockInfo *block)
 592:../../../Source/ARMCM3_STM32/flash.c **** {
 593:../../../Source/ARMCM3_STM32/flash.c ****   blt_int8u  sector_num;
 594:../../../Source/ARMCM3_STM32/flash.c ****   blt_bool   result = BLT_TRUE;
 595:../../../Source/ARMCM3_STM32/flash.c ****   blt_addr   prog_addr;
 596:../../../Source/ARMCM3_STM32/flash.c ****   blt_int32u prog_data;
 597:../../../Source/ARMCM3_STM32/flash.c ****   blt_int32u word_cnt;
 598:../../../Source/ARMCM3_STM32/flash.c **** 
 599:../../../Source/ARMCM3_STM32/flash.c ****   /* check that address is actually within flash */
 600:../../../Source/ARMCM3_STM32/flash.c ****   sector_num = FlashGetSector(block->base_addr);
 601:../../../Source/ARMCM3_STM32/flash.c ****   if (sector_num == FLASH_INVALID_SECTOR)
 602:../../../Source/ARMCM3_STM32/flash.c ****   {
 603:../../../Source/ARMCM3_STM32/flash.c ****     return BLT_FALSE;
 604:../../../Source/ARMCM3_STM32/flash.c ****   }
 605:../../../Source/ARMCM3_STM32/flash.c ****   /* unlock the flash array */
 606:../../../Source/ARMCM3_STM32/flash.c ****   FlashUnlock();
 607:../../../Source/ARMCM3_STM32/flash.c ****   /* check that the flash peripheral is not busy */
 608:../../../Source/ARMCM3_STM32/flash.c ****   if ((FLASH->SR & FLASH_BSY_BIT) == FLASH_BSY_BIT)
 609:../../../Source/ARMCM3_STM32/flash.c ****   {
 610:../../../Source/ARMCM3_STM32/flash.c ****     /* lock the flash array again */
 611:../../../Source/ARMCM3_STM32/flash.c ****     FlashLock();
 612:../../../Source/ARMCM3_STM32/flash.c ****     /* could not perform erase operation */
 613:../../../Source/ARMCM3_STM32/flash.c ****     return BLT_FALSE;
 614:../../../Source/ARMCM3_STM32/flash.c ****   }
 615:../../../Source/ARMCM3_STM32/flash.c ****   /* set the program bit to indicate that we are about to program data */
 616:../../../Source/ARMCM3_STM32/flash.c ****   FLASH->CR |= FLASH_PG_BIT;
 617:../../../Source/ARMCM3_STM32/flash.c ****   /* program all words in the block one by one */
 618:../../../Source/ARMCM3_STM32/flash.c ****   for (word_cnt=0; word_cnt<(FLASH_WRITE_BLOCK_SIZE/sizeof(blt_int32u)); word_cnt++)
 619:../../../Source/ARMCM3_STM32/flash.c ****   {
 620:../../../Source/ARMCM3_STM32/flash.c ****     prog_addr = block->base_addr + (word_cnt * sizeof(blt_int32u));
 621:../../../Source/ARMCM3_STM32/flash.c ****     prog_data = *(volatile blt_int32u*)(&block->data[word_cnt * sizeof(blt_int32u)]);
 622:../../../Source/ARMCM3_STM32/flash.c ****     /* program the first half word */
 623:../../../Source/ARMCM3_STM32/flash.c ****     *(volatile blt_int16u*)prog_addr = (blt_int16u)prog_data;
 624:../../../Source/ARMCM3_STM32/flash.c ****     /* wait for the program operation to complete */
 625:../../../Source/ARMCM3_STM32/flash.c ****     while ((FLASH->SR & FLASH_BSY_BIT) == FLASH_BSY_BIT)
 626:../../../Source/ARMCM3_STM32/flash.c ****     {
 627:../../../Source/ARMCM3_STM32/flash.c ****       /* keep the watchdog happy */
 628:../../../Source/ARMCM3_STM32/flash.c ****       CopService();
 629:../../../Source/ARMCM3_STM32/flash.c ****     }
 630:../../../Source/ARMCM3_STM32/flash.c ****     /* program the second half word */
 631:../../../Source/ARMCM3_STM32/flash.c ****     *(volatile blt_int16u*)(prog_addr+2) = (blt_int16u)(prog_data >> 16);
 632:../../../Source/ARMCM3_STM32/flash.c ****     /* wait for the program operation to complete */
 633:../../../Source/ARMCM3_STM32/flash.c ****     while ((FLASH->SR & FLASH_BSY_BIT) == FLASH_BSY_BIT)
 634:../../../Source/ARMCM3_STM32/flash.c ****     {
 635:../../../Source/ARMCM3_STM32/flash.c ****       /* keep the watchdog happy */
 636:../../../Source/ARMCM3_STM32/flash.c ****       CopService();
 637:../../../Source/ARMCM3_STM32/flash.c ****     }
 638:../../../Source/ARMCM3_STM32/flash.c ****     /* verify that the written data is actually there */
 639:../../../Source/ARMCM3_STM32/flash.c ****     if (*(volatile blt_int32u*)prog_addr != prog_data)
 640:../../../Source/ARMCM3_STM32/flash.c ****     {
 641:../../../Source/ARMCM3_STM32/flash.c ****       result = BLT_FALSE;
 642:../../../Source/ARMCM3_STM32/flash.c ****       break;
 643:../../../Source/ARMCM3_STM32/flash.c ****     }
 644:../../../Source/ARMCM3_STM32/flash.c ****   }
 645:../../../Source/ARMCM3_STM32/flash.c ****   /* reset the program bit to indicate that we are done programming data */
 646:../../../Source/ARMCM3_STM32/flash.c ****   FLASH->CR &= ~FLASH_PG_BIT;
 647:../../../Source/ARMCM3_STM32/flash.c ****   /* lock the flash array */
 648:../../../Source/ARMCM3_STM32/flash.c ****   FlashLock();
 649:../../../Source/ARMCM3_STM32/flash.c ****   /* still here so all is okay */
 650:../../../Source/ARMCM3_STM32/flash.c ****   return result;
 651:../../../Source/ARMCM3_STM32/flash.c **** } /*** end of FlashWriteBlock ***/
 652:../../../Source/ARMCM3_STM32/flash.c **** 
 653:../../../Source/ARMCM3_STM32/flash.c **** 
 654:../../../Source/ARMCM3_STM32/flash.c **** /************************************************************************************//**
 655:../../../Source/ARMCM3_STM32/flash.c **** ** \brief     Erases the flash sectors from first_sector up until last_sector.
 656:../../../Source/ARMCM3_STM32/flash.c **** ** \param     first_sector First flash sector number.
 657:../../../Source/ARMCM3_STM32/flash.c **** ** \param     last_sector  Last flash sector number.
 658:../../../Source/ARMCM3_STM32/flash.c **** ** \return    BLT_TRUE if successful, BLT_FALSE otherwise.
 659:../../../Source/ARMCM3_STM32/flash.c **** **
 660:../../../Source/ARMCM3_STM32/flash.c **** ****************************************************************************************/
 661:../../../Source/ARMCM3_STM32/flash.c **** static blt_bool FlashEraseSectors(blt_int8u first_sector, blt_int8u last_sector)
 662:../../../Source/ARMCM3_STM32/flash.c **** {
 663:../../../Source/ARMCM3_STM32/flash.c ****   blt_int16u nr_of_blocks;
 664:../../../Source/ARMCM3_STM32/flash.c ****   blt_int16u block_cnt;
 665:../../../Source/ARMCM3_STM32/flash.c ****   blt_addr   start_addr;
 666:../../../Source/ARMCM3_STM32/flash.c ****   blt_addr   end_addr;
 667:../../../Source/ARMCM3_STM32/flash.c **** 
 668:../../../Source/ARMCM3_STM32/flash.c ****   /* validate the sector numbers */
 669:../../../Source/ARMCM3_STM32/flash.c ****   if (first_sector > last_sector)
 670:../../../Source/ARMCM3_STM32/flash.c ****   {
 671:../../../Source/ARMCM3_STM32/flash.c ****     return BLT_FALSE;
 672:../../../Source/ARMCM3_STM32/flash.c ****   }
 673:../../../Source/ARMCM3_STM32/flash.c ****   if ( (first_sector < flashLayout[0].sector_num) || \
 674:../../../Source/ARMCM3_STM32/flash.c ****        (last_sector > flashLayout[FLASH_TOTAL_SECTORS-1].sector_num) )
 675:../../../Source/ARMCM3_STM32/flash.c ****   {
 676:../../../Source/ARMCM3_STM32/flash.c ****     return BLT_FALSE;
 677:../../../Source/ARMCM3_STM32/flash.c ****   }
 678:../../../Source/ARMCM3_STM32/flash.c ****   /* unlock the flash array */
 679:../../../Source/ARMCM3_STM32/flash.c ****   FlashUnlock();
 680:../../../Source/ARMCM3_STM32/flash.c ****   /* check that the flash peripheral is not busy */
 681:../../../Source/ARMCM3_STM32/flash.c ****   if ((FLASH->SR & FLASH_BSY_BIT) == FLASH_BSY_BIT)
 682:../../../Source/ARMCM3_STM32/flash.c ****   {
 683:../../../Source/ARMCM3_STM32/flash.c ****     /* lock the flash array again */
 684:../../../Source/ARMCM3_STM32/flash.c ****     FlashLock();
 685:../../../Source/ARMCM3_STM32/flash.c ****     /* could not perform erase operation */
 686:../../../Source/ARMCM3_STM32/flash.c ****     return BLT_FALSE;
 687:../../../Source/ARMCM3_STM32/flash.c ****   }
 688:../../../Source/ARMCM3_STM32/flash.c ****   /* set the page erase bit to indicate that we are about to erase a block */
 689:../../../Source/ARMCM3_STM32/flash.c ****   FLASH->CR |= FLASH_PER_BIT;
 690:../../../Source/ARMCM3_STM32/flash.c **** 
 691:../../../Source/ARMCM3_STM32/flash.c ****   /* determine how many blocks need to be erased */
 692:../../../Source/ARMCM3_STM32/flash.c ****   start_addr = FlashGetSectorBaseAddr(first_sector);
 693:../../../Source/ARMCM3_STM32/flash.c ****   end_addr = FlashGetSectorBaseAddr(last_sector) + FlashGetSectorSize(last_sector) - 1;
 694:../../../Source/ARMCM3_STM32/flash.c ****   nr_of_blocks = (end_addr - start_addr + 1) / FLASH_ERASE_BLOCK_SIZE;
 695:../../../Source/ARMCM3_STM32/flash.c ****   
 696:../../../Source/ARMCM3_STM32/flash.c ****   /* erase all blocks one by one */
 697:../../../Source/ARMCM3_STM32/flash.c ****   for (block_cnt=0; block_cnt<nr_of_blocks; block_cnt++)
 698:../../../Source/ARMCM3_STM32/flash.c ****   {
 699:../../../Source/ARMCM3_STM32/flash.c ****     /* store an address of the block that is to be erased to select the block */
 700:../../../Source/ARMCM3_STM32/flash.c ****     FLASH->AR = start_addr + (block_cnt * FLASH_ERASE_BLOCK_SIZE);
 701:../../../Source/ARMCM3_STM32/flash.c ****     /* start the block erase operation */
 702:../../../Source/ARMCM3_STM32/flash.c ****     FLASH->CR |= FLASH_STRT_BIT;
 703:../../../Source/ARMCM3_STM32/flash.c ****     /* wait for the erase operation to complete */
 704:../../../Source/ARMCM3_STM32/flash.c ****     while ((FLASH->SR & FLASH_BSY_BIT) == FLASH_BSY_BIT)
 705:../../../Source/ARMCM3_STM32/flash.c ****     {
 706:../../../Source/ARMCM3_STM32/flash.c ****       /* keep the watchdog happy */
 707:../../../Source/ARMCM3_STM32/flash.c ****       CopService();
 708:../../../Source/ARMCM3_STM32/flash.c ****     }
 709:../../../Source/ARMCM3_STM32/flash.c ****   }
 710:../../../Source/ARMCM3_STM32/flash.c ****   /* reset the page erase bit because we're all done erasing */
 711:../../../Source/ARMCM3_STM32/flash.c ****   FLASH->CR &= ~FLASH_PER_BIT;
 712:../../../Source/ARMCM3_STM32/flash.c ****   /* lock the flash array */
 713:../../../Source/ARMCM3_STM32/flash.c ****   FlashLock();
 714:../../../Source/ARMCM3_STM32/flash.c ****   /* still here so all went okay */
 715:../../../Source/ARMCM3_STM32/flash.c ****   return BLT_TRUE;
 716:../../../Source/ARMCM3_STM32/flash.c **** } /*** end of FlashEraseSectors ***/
 717:../../../Source/ARMCM3_STM32/flash.c **** 
 718:../../../Source/ARMCM3_STM32/flash.c **** 
 719:../../../Source/ARMCM3_STM32/flash.c **** /************************************************************************************//**
 720:../../../Source/ARMCM3_STM32/flash.c **** ** \brief     Unlocks the flash array so that erase and program operations can be
 721:../../../Source/ARMCM3_STM32/flash.c **** **            performed.
 722:../../../Source/ARMCM3_STM32/flash.c **** ** \return    none.
 723:../../../Source/ARMCM3_STM32/flash.c **** **
 724:../../../Source/ARMCM3_STM32/flash.c **** ****************************************************************************************/
 725:../../../Source/ARMCM3_STM32/flash.c **** static void FlashUnlock(void)
 726:../../../Source/ARMCM3_STM32/flash.c **** {
 727:../../../Source/ARMCM3_STM32/flash.c ****   /* authorize the FPEC to access bank 1 */
 728:../../../Source/ARMCM3_STM32/flash.c ****   FLASH->KEYR = FLASH_KEY1;
 729:../../../Source/ARMCM3_STM32/flash.c ****   FLASH->KEYR = FLASH_KEY2;
 730:../../../Source/ARMCM3_STM32/flash.c ****   /* clear all possibly pending status flags */
 731:../../../Source/ARMCM3_STM32/flash.c ****   FLASH->SR = (FLASH_EOP_BIT | FLASH_PGERR_BIT | FLASH_WRPRTERR_BIT);
 732:../../../Source/ARMCM3_STM32/flash.c **** } /*** end of FlashUnlock ***/
 733:../../../Source/ARMCM3_STM32/flash.c **** 
 734:../../../Source/ARMCM3_STM32/flash.c **** 
 735:../../../Source/ARMCM3_STM32/flash.c **** /************************************************************************************//**
 736:../../../Source/ARMCM3_STM32/flash.c **** ** \brief     Locks the flash array so that erase and program operations can no
 737:../../../Source/ARMCM3_STM32/flash.c **** **            longer be performed.
 738:../../../Source/ARMCM3_STM32/flash.c **** ** \return    none.
 739:../../../Source/ARMCM3_STM32/flash.c **** **
 740:../../../Source/ARMCM3_STM32/flash.c **** ****************************************************************************************/
 741:../../../Source/ARMCM3_STM32/flash.c **** static void FlashLock(void)
 742:../../../Source/ARMCM3_STM32/flash.c **** {
  26              		.loc 1 742 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              		@ link register save eliminated.
 743:../../../Source/ARMCM3_STM32/flash.c ****   /* set the lock bit to lock the FPEC */
 744:../../../Source/ARMCM3_STM32/flash.c ****   FLASH->CR |= FLASH_LOCK_BIT;
  31              		.loc 1 744 0
  32 0000 024A     		ldr	r2, .L2
  33 0002 1369     		ldr	r3, [r2, #16]
  34 0004 43F08003 		orr	r3, r3, #128
  35 0008 1361     		str	r3, [r2, #16]
  36 000a 7047     		bx	lr
  37              	.L3:
  38              		.align	2
  39              	.L2:
  40 000c 00200240 		.word	1073881088
  41              		.cfi_endproc
  42              	.LFE13:
  44              		.section	.text.FlashGetSector,"ax",%progbits
  45              		.align	2
  46              		.thumb
  47              		.thumb_func
  49              	FlashGetSector:
  50              	.LFB14:
 745:../../../Source/ARMCM3_STM32/flash.c **** } /*** end of FlashLock ***/
 746:../../../Source/ARMCM3_STM32/flash.c **** 
 747:../../../Source/ARMCM3_STM32/flash.c **** 
 748:../../../Source/ARMCM3_STM32/flash.c **** /************************************************************************************//**
 749:../../../Source/ARMCM3_STM32/flash.c **** ** \brief     Determines the flash sector the address is in.
 750:../../../Source/ARMCM3_STM32/flash.c **** ** \param     address Address in the flash sector.
 751:../../../Source/ARMCM3_STM32/flash.c **** ** \return    Flash sector number or FLASH_INVALID_SECTOR.
 752:../../../Source/ARMCM3_STM32/flash.c **** **
 753:../../../Source/ARMCM3_STM32/flash.c **** ****************************************************************************************/
 754:../../../Source/ARMCM3_STM32/flash.c **** static blt_int8u FlashGetSector(blt_addr address)
 755:../../../Source/ARMCM3_STM32/flash.c **** {
  51              		.loc 1 755 0
  52              		.cfi_startproc
  53              		@ args = 0, pretend = 0, frame = 0
  54              		@ frame_needed = 0, uses_anonymous_args = 0
  55              	.LVL0:
  56 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
  57              		.cfi_def_cfa_offset 24
  58              		.cfi_offset 3, -24
  59              		.cfi_offset 4, -20
  60              		.cfi_offset 5, -16
  61              		.cfi_offset 6, -12
  62              		.cfi_offset 7, -8
  63              		.cfi_offset 14, -4
  64 0002 0646     		mov	r6, r0
  65              	.LVL1:
  66 0004 0C4C     		ldr	r4, .L10
  67 0006 04F19C07 		add	r7, r4, #156
  68              		.loc 1 755 0
  69 000a 0025     		movs	r5, #0
  70              	.LVL2:
  71              	.L7:
 756:../../../Source/ARMCM3_STM32/flash.c ****   blt_int8u sectorIdx;
 757:../../../Source/ARMCM3_STM32/flash.c ****   
 758:../../../Source/ARMCM3_STM32/flash.c ****   /* search through the sectors to find the right one */
 759:../../../Source/ARMCM3_STM32/flash.c ****   for (sectorIdx = 0; sectorIdx < FLASH_TOTAL_SECTORS; sectorIdx++)
 760:../../../Source/ARMCM3_STM32/flash.c ****   {
 761:../../../Source/ARMCM3_STM32/flash.c ****     /* keep the watchdog happy */
 762:../../../Source/ARMCM3_STM32/flash.c ****     CopService();
  72              		.loc 1 762 0
  73 000c FFF7FEFF 		bl	CopService
  74              	.LVL3:
 763:../../../Source/ARMCM3_STM32/flash.c ****     /* is the address in this sector? */
 764:../../../Source/ARMCM3_STM32/flash.c ****     if ( (address >= flashLayout[sectorIdx].sector_start) && \
  75              		.loc 1 764 0
  76 0010 2368     		ldr	r3, [r4]
  77 0012 B342     		cmp	r3, r6
  78 0014 0AD8     		bhi	.L5
 765:../../../Source/ARMCM3_STM32/flash.c ****          (address < (flashLayout[sectorIdx].sector_start + \
  79              		.loc 1 765 0 discriminator 1
  80 0016 6268     		ldr	r2, [r4, #4]
  81 0018 1344     		add	r3, r3, r2
 764:../../../Source/ARMCM3_STM32/flash.c ****          (address < (flashLayout[sectorIdx].sector_start + \
  82              		.loc 1 764 0 discriminator 1
  83 001a 9E42     		cmp	r6, r3
  84 001c 06D2     		bcs	.L5
 766:../../../Source/ARMCM3_STM32/flash.c ****                   flashLayout[sectorIdx].sector_size)) )
 767:../../../Source/ARMCM3_STM32/flash.c ****     {
 768:../../../Source/ARMCM3_STM32/flash.c ****       /* return the sector number */
 769:../../../Source/ARMCM3_STM32/flash.c ****       return flashLayout[sectorIdx].sector_num;
  85              		.loc 1 769 0
  86 001e 05EB4501 		add	r1, r5, r5, lsl #1
  87 0022 054B     		ldr	r3, .L10
  88 0024 03EB8101 		add	r1, r3, r1, lsl #2
  89 0028 087A     		ldrb	r0, [r1, #8]	@ zero_extendqisi2
  90 002a F8BD     		pop	{r3, r4, r5, r6, r7, pc}
  91              	.LVL4:
  92              	.L5:
  93 002c 0135     		adds	r5, r5, #1
  94              	.LVL5:
  95 002e 0C34     		adds	r4, r4, #12
 759:../../../Source/ARMCM3_STM32/flash.c ****   {
  96              		.loc 1 759 0 discriminator 2
  97 0030 BC42     		cmp	r4, r7
  98 0032 EBD1     		bne	.L7
 770:../../../Source/ARMCM3_STM32/flash.c ****     }
 771:../../../Source/ARMCM3_STM32/flash.c ****   }
 772:../../../Source/ARMCM3_STM32/flash.c ****   /* still here so no valid sector found */
 773:../../../Source/ARMCM3_STM32/flash.c ****   return FLASH_INVALID_SECTOR;
  99              		.loc 1 773 0
 100 0034 FF20     		movs	r0, #255
 774:../../../Source/ARMCM3_STM32/flash.c **** } /*** end of FlashGetSector ***/
 101              		.loc 1 774 0
 102 0036 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 103              	.LVL6:
 104              	.L11:
 105              		.align	2
 106              	.L10:
 107 0038 00000000 		.word	.LANCHOR0
 108              		.cfi_endproc
 109              	.LFE14:
 111              		.section	.text.FlashWriteBlock,"ax",%progbits
 112              		.align	2
 113              		.thumb
 114              		.thumb_func
 116              	FlashWriteBlock:
 117              	.LFB10:
 592:../../../Source/ARMCM3_STM32/flash.c ****   blt_int8u  sector_num;
 118              		.loc 1 592 0
 119              		.cfi_startproc
 120              		@ args = 0, pretend = 0, frame = 0
 121              		@ frame_needed = 0, uses_anonymous_args = 0
 122              	.LVL7:
 123 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 124              		.cfi_def_cfa_offset 24
 125              		.cfi_offset 4, -24
 126              		.cfi_offset 5, -20
 127              		.cfi_offset 6, -16
 128              		.cfi_offset 7, -12
 129              		.cfi_offset 8, -8
 130              		.cfi_offset 14, -4
 131 0004 0746     		mov	r7, r0
 132              	.LVL8:
 600:../../../Source/ARMCM3_STM32/flash.c ****   if (sector_num == FLASH_INVALID_SECTOR)
 133              		.loc 1 600 0
 134 0006 0068     		ldr	r0, [r0]
 135              	.LVL9:
 136 0008 FFF7FEFF 		bl	FlashGetSector
 137              	.LVL10:
 601:../../../Source/ARMCM3_STM32/flash.c ****   {
 138              		.loc 1 601 0
 139 000c FF28     		cmp	r0, #255
 140 000e 49D0     		beq	.L21
 141              	.LBB4:
 142              	.LBB5:
 728:../../../Source/ARMCM3_STM32/flash.c ****   FLASH->KEYR = FLASH_KEY2;
 143              		.loc 1 728 0
 144 0010 264B     		ldr	r3, .L29
 145 0012 274A     		ldr	r2, .L29+4
 146 0014 5A60     		str	r2, [r3, #4]
 729:../../../Source/ARMCM3_STM32/flash.c ****   /* clear all possibly pending status flags */
 147              		.loc 1 729 0
 148 0016 02F18832 		add	r2, r2, #-2004318072
 149 001a 5A60     		str	r2, [r3, #4]
 731:../../../Source/ARMCM3_STM32/flash.c **** } /*** end of FlashUnlock ***/
 150              		.loc 1 731 0
 151 001c 3422     		movs	r2, #52
 152 001e DA60     		str	r2, [r3, #12]
 153              	.LBE5:
 154              	.LBE4:
 608:../../../Source/ARMCM3_STM32/flash.c ****   {
 155              		.loc 1 608 0
 156 0020 DB68     		ldr	r3, [r3, #12]
 157 0022 13F00103 		ands	r3, r3, #1
 158 0026 04D0     		beq	.L14
 611:../../../Source/ARMCM3_STM32/flash.c ****     /* could not perform erase operation */
 159              		.loc 1 611 0
 160 0028 FFF7FEFF 		bl	FlashLock
 161              	.LVL11:
 613:../../../Source/ARMCM3_STM32/flash.c ****   }
 162              		.loc 1 613 0
 163 002c 0020     		movs	r0, #0
 164 002e BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 165              	.LVL12:
 166              	.L14:
 616:../../../Source/ARMCM3_STM32/flash.c ****   /* program all words in the block one by one */
 167              		.loc 1 616 0
 168 0032 1E49     		ldr	r1, .L29
 169 0034 0A69     		ldr	r2, [r1, #16]
 170 0036 42F00102 		orr	r2, r2, #1
 171 003a 0A61     		str	r2, [r1, #16]
 172              	.LVL13:
 625:../../../Source/ARMCM3_STM32/flash.c ****     {
 173              		.loc 1 625 0
 174 003c 0C46     		mov	r4, r1
 175              	.LVL14:
 176              	.L20:
 620:../../../Source/ARMCM3_STM32/flash.c ****     prog_data = *(volatile blt_int32u*)(&block->data[word_cnt * sizeof(blt_int32u)]);
 177              		.loc 1 620 0
 178 003e 3A68     		ldr	r2, [r7]
 179 0040 03EB0208 		add	r8, r3, r2
 180              	.LVL15:
 181 0044 1E1D     		adds	r6, r3, #4
 621:../../../Source/ARMCM3_STM32/flash.c ****     /* program the first half word */
 182              		.loc 1 621 0
 183 0046 BD59     		ldr	r5, [r7, r6]
 184              	.LVL16:
 623:../../../Source/ARMCM3_STM32/flash.c ****     /* wait for the program operation to complete */
 185              		.loc 1 623 0
 186 0048 A9B2     		uxth	r1, r5
 187 004a 9952     		strh	r1, [r3, r2]	@ movhi
 625:../../../Source/ARMCM3_STM32/flash.c ****     {
 188              		.loc 1 625 0
 189 004c E368     		ldr	r3, [r4, #12]
 190 004e 13F0010F 		tst	r3, #1
 191 0052 05D0     		beq	.L15
 192              	.L24:
 628:../../../Source/ARMCM3_STM32/flash.c ****     }
 193              		.loc 1 628 0
 194 0054 FFF7FEFF 		bl	CopService
 195              	.LVL17:
 625:../../../Source/ARMCM3_STM32/flash.c ****     {
 196              		.loc 1 625 0
 197 0058 E368     		ldr	r3, [r4, #12]
 198 005a 13F0010F 		tst	r3, #1
 199 005e F9D1     		bne	.L24
 200              	.L15:
 631:../../../Source/ARMCM3_STM32/flash.c ****     /* wait for the program operation to complete */
 201              		.loc 1 631 0
 202 0060 2B0C     		lsrs	r3, r5, #16
 203 0062 A8F80230 		strh	r3, [r8, #2]	@ movhi
 633:../../../Source/ARMCM3_STM32/flash.c ****     {
 204              		.loc 1 633 0
 205 0066 E368     		ldr	r3, [r4, #12]
 206 0068 13F0010F 		tst	r3, #1
 207 006c 05D0     		beq	.L17
 208              	.L23:
 636:../../../Source/ARMCM3_STM32/flash.c ****     }
 209              		.loc 1 636 0
 210 006e FFF7FEFF 		bl	CopService
 211              	.LVL18:
 633:../../../Source/ARMCM3_STM32/flash.c ****     {
 212              		.loc 1 633 0
 213 0072 E368     		ldr	r3, [r4, #12]
 214 0074 13F0010F 		tst	r3, #1
 215 0078 F9D1     		bne	.L23
 216              	.L17:
 639:../../../Source/ARMCM3_STM32/flash.c ****     {
 217              		.loc 1 639 0
 218 007a D8F80030 		ldr	r3, [r8]
 219 007e AB42     		cmp	r3, r5
 220 0080 05D1     		bne	.L22
 221 0082 3346     		mov	r3, r6
 618:../../../Source/ARMCM3_STM32/flash.c ****   {
 222              		.loc 1 618 0 discriminator 2
 223 0084 B6F5007F 		cmp	r6, #512
 224 0088 D9D1     		bne	.L20
 594:../../../Source/ARMCM3_STM32/flash.c ****   blt_addr   prog_addr;
 225              		.loc 1 594 0
 226 008a 0124     		movs	r4, #1
 227 008c 00E0     		b	.L19
 228              	.L22:
 641:../../../Source/ARMCM3_STM32/flash.c ****       break;
 229              		.loc 1 641 0
 230 008e 0024     		movs	r4, #0
 231              	.L19:
 232              	.LVL19:
 646:../../../Source/ARMCM3_STM32/flash.c ****   /* lock the flash array */
 233              		.loc 1 646 0
 234 0090 064A     		ldr	r2, .L29
 235 0092 1369     		ldr	r3, [r2, #16]
 236 0094 23F00103 		bic	r3, r3, #1
 237 0098 1361     		str	r3, [r2, #16]
 648:../../../Source/ARMCM3_STM32/flash.c ****   /* still here so all is okay */
 238              		.loc 1 648 0
 239 009a FFF7FEFF 		bl	FlashLock
 240              	.LVL20:
 650:../../../Source/ARMCM3_STM32/flash.c **** } /*** end of FlashWriteBlock ***/
 241              		.loc 1 650 0
 242 009e 2046     		mov	r0, r4
 243 00a0 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 244              	.LVL21:
 245              	.L21:
 603:../../../Source/ARMCM3_STM32/flash.c ****   }
 246              		.loc 1 603 0
 247 00a4 0020     		movs	r0, #0
 248              	.LVL22:
 651:../../../Source/ARMCM3_STM32/flash.c **** 
 249              		.loc 1 651 0
 250 00a6 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 251              	.LVL23:
 252              	.L30:
 253 00aa 00BF     		.align	2
 254              	.L29:
 255 00ac 00200240 		.word	1073881088
 256 00b0 23016745 		.word	1164378403
 257              		.cfi_endproc
 258              	.LFE10:
 260              		.section	.text.FlashSwitchBlock,"ax",%progbits
 261              		.align	2
 262              		.thumb
 263              		.thumb_func
 265              	FlashSwitchBlock:
 266              	.LFB8:
 469:../../../Source/ARMCM3_STM32/flash.c ****   /* check if a switch needs to be made away from the boot block. in this case the boot
 267              		.loc 1 469 0
 268              		.cfi_startproc
 269              		@ args = 0, pretend = 0, frame = 0
 270              		@ frame_needed = 0, uses_anonymous_args = 0
 271              	.LVL24:
 272 0000 38B5     		push	{r3, r4, r5, lr}
 273              		.cfi_def_cfa_offset 16
 274              		.cfi_offset 3, -16
 275              		.cfi_offset 4, -12
 276              		.cfi_offset 5, -8
 277              		.cfi_offset 14, -4
 278 0002 0446     		mov	r4, r0
 279 0004 0D46     		mov	r5, r1
 474:../../../Source/ARMCM3_STM32/flash.c ****   {
 280              		.loc 1 474 0
 281 0006 114B     		ldr	r3, .L42
 282 0008 9842     		cmp	r0, r3
 283 000a 06D0     		beq	.L36
 482:../../../Source/ARMCM3_STM32/flash.c ****   {
 284              		.loc 1 482 0
 285 000c 104B     		ldr	r3, .L42+4
 286 000e 9942     		cmp	r1, r3
 287 0010 08D0     		beq	.L37
 491:../../../Source/ARMCM3_STM32/flash.c ****     {
 288              		.loc 1 491 0
 289 0012 FFF7FEFF 		bl	FlashWriteBlock
 290              	.LVL25:
 291 0016 08B9     		cbnz	r0, .L32
 292 0018 11E0     		b	.L38
 293              	.LVL26:
 294              	.L36:
 477:../../../Source/ARMCM3_STM32/flash.c ****   }
 295              		.loc 1 477 0
 296 001a 0E4C     		ldr	r4, .L42+8
 297              	.LVL27:
 298              	.L32:
 299              	.LBB8:
 300              	.LBB9:
 442:../../../Source/ARMCM3_STM32/flash.c ****   {
 301              		.loc 1 442 0
 302 001c C5F30803 		ubfx	r3, r5, #0, #9
 303 0020 7BB9     		cbnz	r3, .L39
 304 0022 00E0     		b	.L33
 305              	.LVL28:
 306              	.L37:
 307              	.LBE9:
 308              	.LBE8:
 485:../../../Source/ARMCM3_STM32/flash.c ****     base_addr = flashLayout[0].sector_start;
 309              		.loc 1 485 0
 310 0024 094C     		ldr	r4, .L42
 311              	.LVL29:
 312              	.L33:
 313              	.LBB11:
 314              	.LBB10:
 447:../../../Source/ARMCM3_STM32/flash.c ****   {
 315              		.loc 1 447 0
 316 0026 2368     		ldr	r3, [r4]
 317 0028 9D42     		cmp	r5, r3
 318 002a 0CD0     		beq	.L35
 453:../../../Source/ARMCM3_STM32/flash.c ****   CpuMemCopy((blt_addr)block->data, address, FLASH_WRITE_BLOCK_SIZE);
 319              		.loc 1 453 0
 320 002c 2046     		mov	r0, r4
 321 002e 40F8045B 		str	r5, [r0], #4
 454:../../../Source/ARMCM3_STM32/flash.c ****   return BLT_TRUE;
 322              		.loc 1 454 0
 323 0032 2946     		mov	r1, r5
 324 0034 4FF40072 		mov	r2, #512
 325 0038 FFF7FEFF 		bl	CpuMemCopy
 326              	.LVL30:
 327 003c 03E0     		b	.L35
 328              	.LVL31:
 329              	.L38:
 330              	.LBE10:
 331              	.LBE11:
 493:../../../Source/ARMCM3_STM32/flash.c ****     }
 332              		.loc 1 493 0
 333 003e 0020     		movs	r0, #0
 334 0040 38BD     		pop	{r3, r4, r5, pc}
 335              	.LVL32:
 336              	.L39:
 500:../../../Source/ARMCM3_STM32/flash.c ****   }
 337              		.loc 1 500 0
 338 0042 0020     		movs	r0, #0
 339 0044 38BD     		pop	{r3, r4, r5, pc}
 340              	.LVL33:
 341              	.L35:
 493:../../../Source/ARMCM3_STM32/flash.c ****     }
 342              		.loc 1 493 0
 343 0046 2046     		mov	r0, r4
 505:../../../Source/ARMCM3_STM32/flash.c **** 
 344              		.loc 1 505 0
 345 0048 38BD     		pop	{r3, r4, r5, pc}
 346              	.LVL34:
 347              	.L43:
 348 004a 00BF     		.align	2
 349              	.L42:
 350 004c 00000000 		.word	.LANCHOR2
 351 0050 00600008 		.word	134242304
 352 0054 00000000 		.word	.LANCHOR1
 353              		.cfi_endproc
 354              	.LFE8:
 356              		.section	.text.FlashAddToBlock,"ax",%progbits
 357              		.align	2
 358              		.thumb
 359              		.thumb_func
 361              	FlashAddToBlock:
 362              	.LFB9:
 522:../../../Source/ARMCM3_STM32/flash.c ****   blt_addr   current_base_addr;
 363              		.loc 1 522 0
 364              		.cfi_startproc
 365              		@ args = 0, pretend = 0, frame = 0
 366              		@ frame_needed = 0, uses_anonymous_args = 0
 367              	.LVL35:
 368 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 369              		.cfi_def_cfa_offset 24
 370              		.cfi_offset 4, -24
 371              		.cfi_offset 5, -20
 372              		.cfi_offset 6, -16
 373              		.cfi_offset 7, -12
 374              		.cfi_offset 8, -8
 375              		.cfi_offset 14, -4
 376 0004 0646     		mov	r6, r0
 377 0006 0C46     		mov	r4, r1
 378 0008 1746     		mov	r7, r2
 379 000a 1D46     		mov	r5, r3
 528:../../../Source/ARMCM3_STM32/flash.c **** 
 380              		.loc 1 528 0
 381 000c 21F4FF78 		bic	r8, r1, #510
 382 0010 28F00108 		bic	r8, r8, #1
 383              	.LVL36:
 531:../../../Source/ARMCM3_STM32/flash.c ****   {
 384              		.loc 1 531 0
 385 0014 0368     		ldr	r3, [r0]
 386              	.LVL37:
 387 0016 B3F1FF3F 		cmp	r3, #-1
 388 001a 06D1     		bne	.L45
 389              	.LVL38:
 390              	.LBB14:
 391              	.LBB15:
 453:../../../Source/ARMCM3_STM32/flash.c ****   CpuMemCopy((blt_addr)block->data, address, FLASH_WRITE_BLOCK_SIZE);
 392              		.loc 1 453 0
 393 001c 40F8048B 		str	r8, [r0], #4
 394              	.LVL39:
 454:../../../Source/ARMCM3_STM32/flash.c ****   return BLT_TRUE;
 395              		.loc 1 454 0
 396 0020 4146     		mov	r1, r8
 397              	.LVL40:
 398 0022 4FF40072 		mov	r2, #512
 399              	.LVL41:
 400 0026 FFF7FEFF 		bl	CpuMemCopy
 401              	.LVL42:
 402              	.L45:
 403              	.LBE15:
 404              	.LBE14:
 541:../../../Source/ARMCM3_STM32/flash.c ****   {
 405              		.loc 1 541 0
 406 002a 3368     		ldr	r3, [r6]
 407 002c 4345     		cmp	r3, r8
 408 002e 05D0     		beq	.L46
 544:../../../Source/ARMCM3_STM32/flash.c ****     if (block == BLT_NULL)
 409              		.loc 1 544 0
 410 0030 3046     		mov	r0, r6
 411 0032 4146     		mov	r1, r8
 412 0034 FFF7FEFF 		bl	FlashSwitchBlock
 413              	.LVL43:
 545:../../../Source/ARMCM3_STM32/flash.c ****     {
 414              		.loc 1 545 0
 415 0038 0646     		mov	r6, r0
 416 003a E0B1     		cbz	r0, .L50
 417              	.LVL44:
 418              	.L46:
 552:../../../Source/ARMCM3_STM32/flash.c ****   src = data;
 419              		.loc 1 552 0
 420 003c 3368     		ldr	r3, [r6]
 421 003e E41A     		subs	r4, r4, r3
 422              	.LVL45:
 423 0040 3444     		add	r4, r4, r6
 424 0042 0434     		adds	r4, r4, #4
 425              	.LVL46:
 562:../../../Source/ARMCM3_STM32/flash.c ****       if (block == BLT_NULL)
 426              		.loc 1 562 0
 427 0044 08F50078 		add	r8, r8, #512
 428              	.LVL47:
 429              	.L49:
 557:../../../Source/ARMCM3_STM32/flash.c ****     /* buffer overflow? */
 430              		.loc 1 557 0
 431 0048 FFF7FEFF 		bl	CopService
 432              	.LVL48:
 559:../../../Source/ARMCM3_STM32/flash.c ****     {
 433              		.loc 1 559 0
 434 004c 331D     		adds	r3, r6, #4
 435 004e E31A     		subs	r3, r4, r3
 436 0050 B3F5007F 		cmp	r3, #512
 437 0054 06D3     		bcc	.L48
 562:../../../Source/ARMCM3_STM32/flash.c ****       if (block == BLT_NULL)
 438              		.loc 1 562 0
 439 0056 3046     		mov	r0, r6
 440 0058 4146     		mov	r1, r8
 441 005a FFF7FEFF 		bl	FlashSwitchBlock
 442              	.LVL49:
 563:../../../Source/ARMCM3_STM32/flash.c ****       {
 443              		.loc 1 563 0
 444 005e 0646     		mov	r6, r0
 445 0060 60B1     		cbz	r0, .L51
 568:../../../Source/ARMCM3_STM32/flash.c ****     }
 446              		.loc 1 568 0
 447 0062 041D     		adds	r4, r0, #4
 448              	.LVL50:
 449              	.L48:
 571:../../../Source/ARMCM3_STM32/flash.c ****     /* update pointers */
 450              		.loc 1 571 0
 451 0064 17F8013B 		ldrb	r3, [r7], #1	@ zero_extendqisi2
 452              	.LVL51:
 453 0068 04F8013B 		strb	r3, [r4], #1
 454              	.LVL52:
 578:../../../Source/ARMCM3_STM32/flash.c ****   /* still here so all is good */
 455              		.loc 1 578 0
 456 006c 013D     		subs	r5, r5, #1
 457              	.LVL53:
 458 006e EBD1     		bne	.L49
 580:../../../Source/ARMCM3_STM32/flash.c **** } /*** end of FlashAddToBlock ***/
 459              		.loc 1 580 0
 460 0070 0120     		movs	r0, #1
 461 0072 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 462              	.LVL54:
 463              	.L50:
 547:../../../Source/ARMCM3_STM32/flash.c ****     }
 464              		.loc 1 547 0
 465 0076 0020     		movs	r0, #0
 466              	.LVL55:
 467 0078 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 468              	.LVL56:
 469              	.L51:
 565:../../../Source/ARMCM3_STM32/flash.c ****       }
 470              		.loc 1 565 0
 471 007c 0020     		movs	r0, #0
 472              	.LVL57:
 581:../../../Source/ARMCM3_STM32/flash.c **** 
 473              		.loc 1 581 0
 474 007e BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 475              		.cfi_endproc
 476              	.LFE9:
 478 0082 00BF     		.section	.text.FlashInit,"ax",%progbits
 479              		.align	2
 480              		.global	FlashInit
 481              		.thumb
 482              		.thumb_func
 484              	FlashInit:
 485              	.LFB0:
 231:../../../Source/ARMCM3_STM32/flash.c ****   /* init the flash block info structs by setting the address to an invalid address */
 486              		.loc 1 231 0
 487              		.cfi_startproc
 488              		@ args = 0, pretend = 0, frame = 0
 489              		@ frame_needed = 0, uses_anonymous_args = 0
 490              		@ link register save eliminated.
 233:../../../Source/ARMCM3_STM32/flash.c ****   bootBlockInfo.base_addr = FLASH_INVALID_ADDRESS;
 491              		.loc 1 233 0
 492 0000 4FF0FF33 		mov	r3, #-1
 493 0004 024A     		ldr	r2, .L55
 494 0006 1360     		str	r3, [r2]
 234:../../../Source/ARMCM3_STM32/flash.c **** } /*** end of FlashInit ***/
 495              		.loc 1 234 0
 496 0008 024A     		ldr	r2, .L55+4
 497 000a 1360     		str	r3, [r2]
 498 000c 7047     		bx	lr
 499              	.L56:
 500 000e 00BF     		.align	2
 501              	.L55:
 502 0010 00000000 		.word	.LANCHOR1
 503 0014 00000000 		.word	.LANCHOR2
 504              		.cfi_endproc
 505              	.LFE0:
 507              		.section	.text.FlashWrite,"ax",%progbits
 508              		.align	2
 509              		.global	FlashWrite
 510              		.thumb
 511              		.thumb_func
 513              	FlashWrite:
 514              	.LFB1:
 249:../../../Source/ARMCM3_STM32/flash.c ****   blt_addr base_addr;
 515              		.loc 1 249 0
 516              		.cfi_startproc
 517              		@ args = 0, pretend = 0, frame = 0
 518              		@ frame_needed = 0, uses_anonymous_args = 0
 519              	.LVL58:
 520 0000 70B5     		push	{r4, r5, r6, lr}
 521              		.cfi_def_cfa_offset 16
 522              		.cfi_offset 4, -16
 523              		.cfi_offset 5, -12
 524              		.cfi_offset 6, -8
 525              		.cfi_offset 14, -4
 526 0002 0446     		mov	r4, r0
 527 0004 0D46     		mov	r5, r1
 528 0006 1646     		mov	r6, r2
 253:../../../Source/ARMCM3_STM32/flash.c ****        (FlashGetSector(addr+len-1) == FLASH_INVALID_SECTOR) )
 529              		.loc 1 253 0
 530 0008 FFF7FEFF 		bl	FlashGetSector
 531              	.LVL59:
 532 000c FF28     		cmp	r0, #255
 533 000e 14D0     		beq	.L60
 534 0010 681E     		subs	r0, r5, #1
 254:../../../Source/ARMCM3_STM32/flash.c ****   {
 535              		.loc 1 254 0 discriminator 1
 536 0012 2044     		add	r0, r0, r4
 537 0014 FFF7FEFF 		bl	FlashGetSector
 538              	.LVL60:
 253:../../../Source/ARMCM3_STM32/flash.c ****        (FlashGetSector(addr+len-1) == FLASH_INVALID_SECTOR) )
 539              		.loc 1 253 0 discriminator 1
 540 0018 FF28     		cmp	r0, #255
 541 001a 10D0     		beq	.L61
 542              	.LVL61:
 260:../../../Source/ARMCM3_STM32/flash.c ****   if (base_addr == flashLayout[0].sector_start)
 543              		.loc 1 260 0
 544 001c 24F4FF73 		bic	r3, r4, #510
 545 0020 23F00103 		bic	r3, r3, #1
 261:../../../Source/ARMCM3_STM32/flash.c ****   {
 546              		.loc 1 261 0
 547 0024 074A     		ldr	r2, .L63
 548 0026 9342     		cmp	r3, r2
 264:../../../Source/ARMCM3_STM32/flash.c ****   }
 549              		.loc 1 264 0
 550 0028 0CBF     		ite	eq
 551 002a 0748     		ldreq	r0, .L63+4
 267:../../../Source/ARMCM3_STM32/flash.c **** } /*** end of FlashWrite ***/
 552              		.loc 1 267 0
 553 002c 0748     		ldrne	r0, .L63+8
 554 002e 2146     		mov	r1, r4
 555 0030 3246     		mov	r2, r6
 556 0032 2B46     		mov	r3, r5
 557 0034 FFF7FEFF 		bl	FlashAddToBlock
 558              	.LVL62:
 559 0038 70BD     		pop	{r4, r5, r6, pc}
 560              	.LVL63:
 561              	.L60:
 256:../../../Source/ARMCM3_STM32/flash.c ****   }
 562              		.loc 1 256 0
 563 003a 0020     		movs	r0, #0
 564 003c 70BD     		pop	{r4, r5, r6, pc}
 565              	.LVL64:
 566              	.L61:
 567 003e 0020     		movs	r0, #0
 268:../../../Source/ARMCM3_STM32/flash.c **** 
 568              		.loc 1 268 0
 569 0040 70BD     		pop	{r4, r5, r6, pc}
 570              	.LVL65:
 571              	.L64:
 572 0042 00BF     		.align	2
 573              	.L63:
 574 0044 00600008 		.word	134242304
 575 0048 00000000 		.word	.LANCHOR2
 576 004c 00000000 		.word	.LANCHOR1
 577              		.cfi_endproc
 578              	.LFE1:
 580              		.section	.text.FlashErase,"ax",%progbits
 581              		.align	2
 582              		.global	FlashErase
 583              		.thumb
 584              		.thumb_func
 586              	FlashErase:
 587              	.LFB2:
 281:../../../Source/ARMCM3_STM32/flash.c ****   blt_int8u first_sector;
 588              		.loc 1 281 0
 589              		.cfi_startproc
 590              		@ args = 0, pretend = 0, frame = 0
 591              		@ frame_needed = 0, uses_anonymous_args = 0
 592              	.LVL66:
 593 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 594              		.cfi_def_cfa_offset 24
 595              		.cfi_offset 4, -24
 596              		.cfi_offset 5, -20
 597              		.cfi_offset 6, -16
 598              		.cfi_offset 7, -12
 599              		.cfi_offset 8, -8
 600              		.cfi_offset 14, -4
 601 0004 0646     		mov	r6, r0
 602 0006 0C46     		mov	r4, r1
 286:../../../Source/ARMCM3_STM32/flash.c ****   last_sector  = FlashGetSector(addr+len-1);
 603              		.loc 1 286 0
 604 0008 FFF7FEFF 		bl	FlashGetSector
 605              	.LVL67:
 606 000c 0546     		mov	r5, r0
 607              	.LVL68:
 608 000e 601E     		subs	r0, r4, #1
 287:../../../Source/ARMCM3_STM32/flash.c ****   /* check them */
 609              		.loc 1 287 0
 610 0010 3044     		add	r0, r0, r6
 611 0012 FFF7FEFF 		bl	FlashGetSector
 612              	.LVL69:
 613 0016 0446     		mov	r4, r0
 614              	.LVL70:
 615              	.LBB26:
 616              	.LBB27:
 669:../../../Source/ARMCM3_STM32/flash.c ****   {
 617              		.loc 1 669 0
 618 0018 8542     		cmp	r5, r0
 619 001a 00F28580 		bhi	.L81
 673:../../../Source/ARMCM3_STM32/flash.c ****        (last_sector > flashLayout[FLASH_TOTAL_SECTORS-1].sector_num) )
 620              		.loc 1 673 0
 621 001e EB1E     		subs	r3, r5, #3
 622 0020 DBB2     		uxtb	r3, r3
 623 0022 FB2B     		cmp	r3, #251
 624 0024 00F28380 		bhi	.L82
 625 0028 0F28     		cmp	r0, #15
 626 002a 00F28380 		bhi	.L83
 627              	.LBB28:
 628              	.LBB29:
 728:../../../Source/ARMCM3_STM32/flash.c ****   FLASH->KEYR = FLASH_KEY2;
 629              		.loc 1 728 0
 630 002e 434B     		ldr	r3, .L91
 631 0030 434A     		ldr	r2, .L91+4
 632 0032 5A60     		str	r2, [r3, #4]
 729:../../../Source/ARMCM3_STM32/flash.c ****   /* clear all possibly pending status flags */
 633              		.loc 1 729 0
 634 0034 02F18832 		add	r2, r2, #-2004318072
 635 0038 5A60     		str	r2, [r3, #4]
 731:../../../Source/ARMCM3_STM32/flash.c **** } /*** end of FlashUnlock ***/
 636              		.loc 1 731 0
 637 003a 3422     		movs	r2, #52
 638 003c DA60     		str	r2, [r3, #12]
 639              	.LBE29:
 640              	.LBE28:
 681:../../../Source/ARMCM3_STM32/flash.c ****   {
 641              		.loc 1 681 0
 642 003e DB68     		ldr	r3, [r3, #12]
 643 0040 13F0010F 		tst	r3, #1
 644 0044 04D0     		beq	.L67
 684:../../../Source/ARMCM3_STM32/flash.c ****     /* could not perform erase operation */
 645              		.loc 1 684 0
 646 0046 FFF7FEFF 		bl	FlashLock
 647              	.LVL71:
 686:../../../Source/ARMCM3_STM32/flash.c ****   }
 648              		.loc 1 686 0
 649 004a 0020     		movs	r0, #0
 650 004c BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 651              	.LVL72:
 652              	.L67:
 689:../../../Source/ARMCM3_STM32/flash.c **** 
 653              		.loc 1 689 0
 654 0050 3A4A     		ldr	r2, .L91
 655 0052 1369     		ldr	r3, [r2, #16]
 656 0054 43F00203 		orr	r3, r3, #2
 657 0058 1361     		str	r3, [r2, #16]
 658              	.LVL73:
 659 005a 3A4F     		ldr	r7, .L91+8
 660 005c B846     		mov	r8, r7
 661 005e 0026     		movs	r6, #0
 662              	.LVL74:
 663              	.L70:
 664              	.LBB30:
 665              	.LBB31:
 775:../../../Source/ARMCM3_STM32/flash.c **** 
 776:../../../Source/ARMCM3_STM32/flash.c **** 
 777:../../../Source/ARMCM3_STM32/flash.c **** /************************************************************************************//**
 778:../../../Source/ARMCM3_STM32/flash.c **** ** \brief     Determines the flash sector base address.
 779:../../../Source/ARMCM3_STM32/flash.c **** ** \param     sector Sector to get the base address of.
 780:../../../Source/ARMCM3_STM32/flash.c **** ** \return    Flash sector base address or FLASH_INVALID_ADDRESS.
 781:../../../Source/ARMCM3_STM32/flash.c **** **
 782:../../../Source/ARMCM3_STM32/flash.c **** ****************************************************************************************/
 783:../../../Source/ARMCM3_STM32/flash.c **** static blt_addr FlashGetSectorBaseAddr(blt_int8u sector)
 784:../../../Source/ARMCM3_STM32/flash.c **** {
 785:../../../Source/ARMCM3_STM32/flash.c ****   blt_int8u sectorIdx;
 786:../../../Source/ARMCM3_STM32/flash.c ****   
 787:../../../Source/ARMCM3_STM32/flash.c ****   /* search through the sectors to find the right one */
 788:../../../Source/ARMCM3_STM32/flash.c ****   for (sectorIdx = 0; sectorIdx < FLASH_TOTAL_SECTORS; sectorIdx++)
 789:../../../Source/ARMCM3_STM32/flash.c ****   {
 790:../../../Source/ARMCM3_STM32/flash.c ****     /* keep the watchdog happy */
 791:../../../Source/ARMCM3_STM32/flash.c ****     CopService();
 666              		.loc 1 791 0
 667 0060 FFF7FEFF 		bl	CopService
 668              	.LVL75:
 792:../../../Source/ARMCM3_STM32/flash.c ****     if (flashLayout[sectorIdx].sector_num == sector)
 669              		.loc 1 792 0
 670 0064 98F80830 		ldrb	r3, [r8, #8]	@ zero_extendqisi2
 671 0068 AB42     		cmp	r3, r5
 672 006a 05D1     		bne	.L68
 793:../../../Source/ARMCM3_STM32/flash.c ****     {
 794:../../../Source/ARMCM3_STM32/flash.c ****       return flashLayout[sectorIdx].sector_start;
 673              		.loc 1 794 0
 674 006c 06EB4602 		add	r2, r6, r6, lsl #1
 675 0070 344B     		ldr	r3, .L91+8
 676 0072 53F82250 		ldr	r5, [r3, r2, lsl #2]
 677              	.LVL76:
 678 0076 06E0     		b	.L69
 679              	.LVL77:
 680              	.L68:
 681 0078 0136     		adds	r6, r6, #1
 682              	.LVL78:
 683 007a 08F10C08 		add	r8, r8, #12
 788:../../../Source/ARMCM3_STM32/flash.c ****   {
 684              		.loc 1 788 0
 685 007e 0D2E     		cmp	r6, #13
 686 0080 EED1     		bne	.L70
 795:../../../Source/ARMCM3_STM32/flash.c ****     }
 796:../../../Source/ARMCM3_STM32/flash.c ****   }
 797:../../../Source/ARMCM3_STM32/flash.c ****   /* still here so no valid sector found */
 798:../../../Source/ARMCM3_STM32/flash.c ****   return FLASH_INVALID_ADDRESS;
 687              		.loc 1 798 0
 688 0082 4FF0FF35 		mov	r5, #-1
 689              	.LVL79:
 690              	.L69:
 691 0086 B846     		mov	r8, r7
 692 0088 0026     		movs	r6, #0
 693              	.LVL80:
 694              	.L73:
 695              	.LBE31:
 696              	.LBE30:
 697              	.LBB32:
 698              	.LBB33:
 791:../../../Source/ARMCM3_STM32/flash.c ****     if (flashLayout[sectorIdx].sector_num == sector)
 699              		.loc 1 791 0
 700 008a FFF7FEFF 		bl	CopService
 701              	.LVL81:
 792:../../../Source/ARMCM3_STM32/flash.c ****     {
 702              		.loc 1 792 0
 703 008e 98F80830 		ldrb	r3, [r8, #8]	@ zero_extendqisi2
 704 0092 A342     		cmp	r3, r4
 705 0094 05D1     		bne	.L71
 794:../../../Source/ARMCM3_STM32/flash.c ****     }
 706              		.loc 1 794 0
 707 0096 06EB4602 		add	r2, r6, r6, lsl #1
 708 009a 2A4B     		ldr	r3, .L91+8
 709 009c 53F82280 		ldr	r8, [r3, r2, lsl #2]
 710 00a0 06E0     		b	.L72
 711              	.L71:
 712              	.LVL82:
 713 00a2 0136     		adds	r6, r6, #1
 714              	.LVL83:
 715 00a4 08F10C08 		add	r8, r8, #12
 788:../../../Source/ARMCM3_STM32/flash.c ****   {
 716              		.loc 1 788 0
 717 00a8 0D2E     		cmp	r6, #13
 718 00aa EED1     		bne	.L73
 719              		.loc 1 798 0
 720 00ac 4FF0FF38 		mov	r8, #-1
 721              	.L72:
 722              	.LVL84:
 723 00b0 0026     		movs	r6, #0
 724              	.LVL85:
 725              	.L76:
 726              	.LBE33:
 727              	.LBE32:
 728              	.LBB34:
 729              	.LBB35:
 799:../../../Source/ARMCM3_STM32/flash.c **** } /*** end of FlashGetSectorBaseAddr ***/
 800:../../../Source/ARMCM3_STM32/flash.c **** 
 801:../../../Source/ARMCM3_STM32/flash.c **** 
 802:../../../Source/ARMCM3_STM32/flash.c **** /************************************************************************************//**
 803:../../../Source/ARMCM3_STM32/flash.c **** ** \brief     Determines the flash sector size.
 804:../../../Source/ARMCM3_STM32/flash.c **** ** \param     sector Sector to get the size of.
 805:../../../Source/ARMCM3_STM32/flash.c **** ** \return    Flash sector size or 0.
 806:../../../Source/ARMCM3_STM32/flash.c **** **
 807:../../../Source/ARMCM3_STM32/flash.c **** ****************************************************************************************/
 808:../../../Source/ARMCM3_STM32/flash.c **** static blt_addr FlashGetSectorSize(blt_int8u sector)
 809:../../../Source/ARMCM3_STM32/flash.c **** {
 810:../../../Source/ARMCM3_STM32/flash.c ****   blt_int8u sectorIdx;
 811:../../../Source/ARMCM3_STM32/flash.c ****   
 812:../../../Source/ARMCM3_STM32/flash.c ****   /* search through the sectors to find the right one */
 813:../../../Source/ARMCM3_STM32/flash.c ****   for (sectorIdx = 0; sectorIdx < FLASH_TOTAL_SECTORS; sectorIdx++)
 814:../../../Source/ARMCM3_STM32/flash.c ****   {
 815:../../../Source/ARMCM3_STM32/flash.c ****     /* keep the watchdog happy */
 816:../../../Source/ARMCM3_STM32/flash.c ****     CopService();
 730              		.loc 1 816 0
 731 00b2 FFF7FEFF 		bl	CopService
 732              	.LVL86:
 817:../../../Source/ARMCM3_STM32/flash.c ****     if (flashLayout[sectorIdx].sector_num == sector)
 733              		.loc 1 817 0
 734 00b6 3B7A     		ldrb	r3, [r7, #8]	@ zero_extendqisi2
 735 00b8 A342     		cmp	r3, r4
 736 00ba 06D1     		bne	.L74
 818:../../../Source/ARMCM3_STM32/flash.c ****     {
 819:../../../Source/ARMCM3_STM32/flash.c ****       return flashLayout[sectorIdx].sector_size;
 737              		.loc 1 819 0
 738 00bc 06EB4602 		add	r2, r6, r6, lsl #1
 739 00c0 204B     		ldr	r3, .L91+8
 740 00c2 03EB8202 		add	r2, r3, r2, lsl #2
 741 00c6 5368     		ldr	r3, [r2, #4]
 742 00c8 04E0     		b	.L75
 743              	.L74:
 744              	.LVL87:
 745 00ca 0136     		adds	r6, r6, #1
 746              	.LVL88:
 747 00cc 0C37     		adds	r7, r7, #12
 813:../../../Source/ARMCM3_STM32/flash.c ****   {
 748              		.loc 1 813 0
 749 00ce 0D2E     		cmp	r6, #13
 750 00d0 EFD1     		bne	.L76
 820:../../../Source/ARMCM3_STM32/flash.c ****     }
 821:../../../Source/ARMCM3_STM32/flash.c ****   }
 822:../../../Source/ARMCM3_STM32/flash.c ****   /* still here so no valid sector found */
 823:../../../Source/ARMCM3_STM32/flash.c ****   return 0;
 751              		.loc 1 823 0
 752 00d2 0023     		movs	r3, #0
 753              	.L75:
 754              	.LVL89:
 755 00d4 C5EB0808 		rsb	r8, r5, r8
 756              	.LVL90:
 757              	.LBE35:
 758              	.LBE34:
 694:../../../Source/ARMCM3_STM32/flash.c ****   
 759              		.loc 1 694 0
 760 00d8 4344     		add	r3, r3, r8
 761 00da C3F38F23 		ubfx	r3, r3, #10, #16
 762              	.LVL91:
 697:../../../Source/ARMCM3_STM32/flash.c ****   {
 763              		.loc 1 697 0
 764 00de CBB1     		cbz	r3, .L77
 765 00e0 05F58066 		add	r6, r5, #1024
 766 00e4 013B     		subs	r3, r3, #1
 767              	.LVL92:
 768 00e6 9AB2     		uxth	r2, r3
 769 00e8 06EB8226 		add	r6, r6, r2, lsl #10
 700:../../../Source/ARMCM3_STM32/flash.c ****     /* start the block erase operation */
 770              		.loc 1 700 0
 771 00ec 134C     		ldr	r4, .L91
 772              	.LVL93:
 773              	.L80:
 774 00ee 6561     		str	r5, [r4, #20]
 702:../../../Source/ARMCM3_STM32/flash.c ****     /* wait for the erase operation to complete */
 775              		.loc 1 702 0
 776 00f0 2369     		ldr	r3, [r4, #16]
 777 00f2 43F04003 		orr	r3, r3, #64
 778 00f6 2361     		str	r3, [r4, #16]
 704:../../../Source/ARMCM3_STM32/flash.c ****     {
 779              		.loc 1 704 0
 780 00f8 E368     		ldr	r3, [r4, #12]
 781 00fa 13F0010F 		tst	r3, #1
 782 00fe 05D0     		beq	.L78
 783              	.L84:
 707:../../../Source/ARMCM3_STM32/flash.c ****     }
 784              		.loc 1 707 0
 785 0100 FFF7FEFF 		bl	CopService
 786              	.LVL94:
 704:../../../Source/ARMCM3_STM32/flash.c ****     {
 787              		.loc 1 704 0
 788 0104 E368     		ldr	r3, [r4, #12]
 789 0106 13F0010F 		tst	r3, #1
 790 010a F9D1     		bne	.L84
 791              	.L78:
 792 010c 05F58065 		add	r5, r5, #1024
 697:../../../Source/ARMCM3_STM32/flash.c ****   {
 793              		.loc 1 697 0
 794 0110 B542     		cmp	r5, r6
 795 0112 ECD1     		bne	.L80
 796              	.L77:
 711:../../../Source/ARMCM3_STM32/flash.c ****   /* lock the flash array */
 797              		.loc 1 711 0
 798 0114 094A     		ldr	r2, .L91
 799 0116 1369     		ldr	r3, [r2, #16]
 800 0118 23F00203 		bic	r3, r3, #2
 801 011c 1361     		str	r3, [r2, #16]
 713:../../../Source/ARMCM3_STM32/flash.c ****   /* still here so all went okay */
 802              		.loc 1 713 0
 803 011e FFF7FEFF 		bl	FlashLock
 804              	.LVL95:
 715:../../../Source/ARMCM3_STM32/flash.c **** } /*** end of FlashEraseSectors ***/
 805              		.loc 1 715 0
 806 0122 0120     		movs	r0, #1
 807 0124 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 808              	.LVL96:
 809              	.L81:
 671:../../../Source/ARMCM3_STM32/flash.c ****   }
 810              		.loc 1 671 0
 811 0128 0020     		movs	r0, #0
 812              	.LVL97:
 813 012a BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 814              	.LVL98:
 815              	.L82:
 676:../../../Source/ARMCM3_STM32/flash.c ****   }
 816              		.loc 1 676 0
 817 012e 0020     		movs	r0, #0
 818              	.LVL99:
 819 0130 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 820              	.LVL100:
 821              	.L83:
 822 0134 0020     		movs	r0, #0
 823              	.LVL101:
 824              	.LBE27:
 825              	.LBE26:
 295:../../../Source/ARMCM3_STM32/flash.c **** 
 826              		.loc 1 295 0
 827 0136 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 828              	.LVL102:
 829              	.L92:
 830 013a 00BF     		.align	2
 831              	.L91:
 832 013c 00200240 		.word	1073881088
 833 0140 23016745 		.word	1164378403
 834 0144 00000000 		.word	.LANCHOR0
 835              		.cfi_endproc
 836              	.LFE2:
 838              		.section	.text.FlashWriteChecksum,"ax",%progbits
 839              		.align	2
 840              		.global	FlashWriteChecksum
 841              		.thumb
 842              		.thumb_func
 844              	FlashWriteChecksum:
 845              	.LFB3:
 308:../../../Source/ARMCM3_STM32/flash.c ****   blt_int32u signature_checksum = 0;
 846              		.loc 1 308 0
 847              		.cfi_startproc
 848              		@ args = 0, pretend = 0, frame = 8
 849              		@ frame_needed = 0, uses_anonymous_args = 0
 335:../../../Source/ARMCM3_STM32/flash.c ****    {
 850              		.loc 1 335 0
 851 0000 114B     		ldr	r3, .L98
 852 0002 1B68     		ldr	r3, [r3]
 853 0004 B3F1FF3F 		cmp	r3, #-1
 854 0008 18D0     		beq	.L95
 308:../../../Source/ARMCM3_STM32/flash.c ****   blt_int32u signature_checksum = 0;
 855              		.loc 1 308 0
 856 000a 00B5     		push	{lr}
 857              		.cfi_def_cfa_offset 4
 858              		.cfi_offset 14, -4
 859 000c 83B0     		sub	sp, sp, #12
 860              		.cfi_def_cfa_offset 16
 344:../../../Source/ARMCM3_STM32/flash.c ****   signature_checksum += *((blt_int32u*)(&bootBlockInfo.data[0+0x08]));
 861              		.loc 1 344 0
 862 000e 0E4B     		ldr	r3, .L98
 863 0010 9968     		ldr	r1, [r3, #8]
 864 0012 5A68     		ldr	r2, [r3, #4]
 865 0014 1144     		add	r1, r1, r2
 345:../../../Source/ARMCM3_STM32/flash.c ****   signature_checksum += *((blt_int32u*)(&bootBlockInfo.data[0+0x0C]));
 866              		.loc 1 345 0
 867 0016 DA68     		ldr	r2, [r3, #12]
 868 0018 1144     		add	r1, r1, r2
 346:../../../Source/ARMCM3_STM32/flash.c ****   signature_checksum += *((blt_int32u*)(&bootBlockInfo.data[0+0x10]));
 869              		.loc 1 346 0
 870 001a 1A69     		ldr	r2, [r3, #16]
 871 001c 1144     		add	r1, r1, r2
 347:../../../Source/ARMCM3_STM32/flash.c ****   signature_checksum += *((blt_int32u*)(&bootBlockInfo.data[0+0x14]));
 872              		.loc 1 347 0
 873 001e 5A69     		ldr	r2, [r3, #20]
 874 0020 1144     		add	r1, r1, r2
 348:../../../Source/ARMCM3_STM32/flash.c ****   signature_checksum += *((blt_int32u*)(&bootBlockInfo.data[0+0x18]));
 875              		.loc 1 348 0
 876 0022 9A69     		ldr	r2, [r3, #24]
 877 0024 1144     		add	r1, r1, r2
 349:../../../Source/ARMCM3_STM32/flash.c ****   signature_checksum  = ~signature_checksum; /* one's complement */
 878              		.loc 1 349 0
 879 0026 DA69     		ldr	r2, [r3, #28]
 880 0028 8B18     		adds	r3, r1, r2
 351:../../../Source/ARMCM3_STM32/flash.c **** 
 881              		.loc 1 351 0
 882 002a 5B42     		negs	r3, r3
 883 002c 02AA     		add	r2, sp, #8
 884 002e 42F8043D 		str	r3, [r2, #-4]!
 354:../../../Source/ARMCM3_STM32/flash.c ****                     sizeof(blt_addr), (blt_int8u*)&signature_checksum);
 885              		.loc 1 354 0
 886 0032 0648     		ldr	r0, .L98+4
 887 0034 0421     		movs	r1, #4
 888 0036 FFF7FEFF 		bl	FlashWrite
 889              	.LVL103:
 890 003a 01E0     		b	.L94
 891              	.L95:
 892              		.cfi_def_cfa_offset 0
 893              		.cfi_restore 14
 337:../../../Source/ARMCM3_STM32/flash.c ****    }
 894              		.loc 1 337 0
 895 003c 0120     		movs	r0, #1
 896 003e 7047     		bx	lr
 897              	.L94:
 898              		.cfi_def_cfa_offset 16
 899              		.cfi_offset 14, -4
 356:../../../Source/ARMCM3_STM32/flash.c **** 
 900              		.loc 1 356 0
 901 0040 03B0     		add	sp, sp, #12
 902              		.cfi_def_cfa_offset 4
 903              		@ sp needed
 904 0042 5DF804FB 		ldr	pc, [sp], #4
 905              	.L99:
 906 0046 00BF     		.align	2
 907              	.L98:
 908 0048 00000000 		.word	.LANCHOR2
 909 004c 50610008 		.word	134242640
 910              		.cfi_endproc
 911              	.LFE3:
 913              		.section	.text.FlashVerifyChecksum,"ax",%progbits
 914              		.align	2
 915              		.global	FlashVerifyChecksum
 916              		.thumb
 917              		.thumb_func
 919              	FlashVerifyChecksum:
 920              	.LFB4:
 366:../../../Source/ARMCM3_STM32/flash.c ****   blt_int32u signature_checksum = 0;
 921              		.loc 1 366 0
 922              		.cfi_startproc
 923              		@ args = 0, pretend = 0, frame = 0
 924              		@ frame_needed = 0, uses_anonymous_args = 0
 925              		@ link register save eliminated.
 926              	.LVL104:
 371:../../../Source/ARMCM3_STM32/flash.c ****   signature_checksum += *((blt_int32u*)(flashLayout[0].sector_start+0x08));
 927              		.loc 1 371 0
 928 0000 0D4B     		ldr	r3, .L101
 929 0002 1A68     		ldr	r2, [r3]
 930 0004 043B     		subs	r3, r3, #4
 931 0006 1B68     		ldr	r3, [r3]
 932 0008 1344     		add	r3, r3, r2
 933              	.LVL105:
 372:../../../Source/ARMCM3_STM32/flash.c ****   signature_checksum += *((blt_int32u*)(flashLayout[0].sector_start+0x0C));
 934              		.loc 1 372 0
 935 000a 0C4A     		ldr	r2, .L101+4
 936 000c 1268     		ldr	r2, [r2]
 937 000e 1344     		add	r3, r3, r2
 938              	.LVL106:
 373:../../../Source/ARMCM3_STM32/flash.c ****   signature_checksum += *((blt_int32u*)(flashLayout[0].sector_start+0x10));
 939              		.loc 1 373 0
 940 0010 0B4A     		ldr	r2, .L101+8
 941 0012 1268     		ldr	r2, [r2]
 942 0014 1344     		add	r3, r3, r2
 943              	.LVL107:
 374:../../../Source/ARMCM3_STM32/flash.c ****   signature_checksum += *((blt_int32u*)(flashLayout[0].sector_start+0x14));
 944              		.loc 1 374 0
 945 0016 0B4A     		ldr	r2, .L101+12
 946 0018 1168     		ldr	r1, [r2]
 947 001a 0B44     		add	r3, r3, r1
 948              	.LVL108:
 375:../../../Source/ARMCM3_STM32/flash.c ****   signature_checksum += *((blt_int32u*)(flashLayout[0].sector_start+0x18));
 949              		.loc 1 375 0
 950 001c 0432     		adds	r2, r2, #4
 951 001e 1268     		ldr	r2, [r2]
 952 0020 1A44     		add	r2, r2, r3
 953              	.LVL109:
 376:../../../Source/ARMCM3_STM32/flash.c ****   signature_checksum += *((blt_int32u*)(flashLayout[0].sector_start+FLASH_VECTOR_TABLE_CS_OFFSET));
 954              		.loc 1 376 0
 955 0022 094B     		ldr	r3, .L101+16
 956 0024 1B68     		ldr	r3, [r3]
 957 0026 1344     		add	r3, r3, r2
 958              	.LVL110:
 377:../../../Source/ARMCM3_STM32/flash.c ****   /* sum should add up to an unsigned 32-bit value of 0 */
 959              		.loc 1 377 0
 960 0028 084A     		ldr	r2, .L101+20
 961              	.LVL111:
 962 002a 1268     		ldr	r2, [r2]
 963              	.LVL112:
 379:../../../Source/ARMCM3_STM32/flash.c ****   {
 964              		.loc 1 379 0
 965 002c D342     		cmn	r3, r2
 386:../../../Source/ARMCM3_STM32/flash.c **** 
 966              		.loc 1 386 0
 967 002e 0CBF     		ite	eq
 968 0030 0120     		moveq	r0, #1
 969 0032 0020     		movne	r0, #0
 970 0034 7047     		bx	lr
 971              	.L102:
 972 0036 00BF     		.align	2
 973              	.L101:
 974 0038 04600008 		.word	134242308
 975 003c 08600008 		.word	134242312
 976 0040 0C600008 		.word	134242316
 977 0044 10600008 		.word	134242320
 978 0048 18600008 		.word	134242328
 979 004c 50610008 		.word	134242640
 980              		.cfi_endproc
 981              	.LFE4:
 983              		.section	.text.FlashDone,"ax",%progbits
 984              		.align	2
 985              		.global	FlashDone
 986              		.thumb
 987              		.thumb_func
 989              	FlashDone:
 990              	.LFB5:
 396:../../../Source/ARMCM3_STM32/flash.c ****   /* check if there is still data waiting to be programmed in the boot block */
 991              		.loc 1 396 0
 992              		.cfi_startproc
 993              		@ args = 0, pretend = 0, frame = 0
 994              		@ frame_needed = 0, uses_anonymous_args = 0
 995 0000 08B5     		push	{r3, lr}
 996              		.cfi_def_cfa_offset 8
 997              		.cfi_offset 3, -8
 998              		.cfi_offset 14, -4
 398:../../../Source/ARMCM3_STM32/flash.c ****   {
 999              		.loc 1 398 0
 1000 0002 0C4B     		ldr	r3, .L108
 1001 0004 1B68     		ldr	r3, [r3]
 1002 0006 B3F1FF3F 		cmp	r3, #-1
 1003 000a 04D0     		beq	.L104
 400:../../../Source/ARMCM3_STM32/flash.c ****     {
 1004              		.loc 1 400 0
 1005 000c 0948     		ldr	r0, .L108
 1006 000e FFF7FEFF 		bl	FlashWriteBlock
 1007              	.LVL113:
 1008 0012 0346     		mov	r3, r0
 1009 0014 60B1     		cbz	r0, .L105
 1010              	.L104:
 407:../../../Source/ARMCM3_STM32/flash.c ****   {
 1011              		.loc 1 407 0
 1012 0016 084B     		ldr	r3, .L108+4
 1013 0018 1B68     		ldr	r3, [r3]
 1014 001a B3F1FF3F 		cmp	r3, #-1
 1015 001e 06D0     		beq	.L106
 409:../../../Source/ARMCM3_STM32/flash.c ****     {
 1016              		.loc 1 409 0
 1017 0020 0548     		ldr	r0, .L108+4
 1018 0022 FFF7FEFF 		bl	FlashWriteBlock
 1019              	.LVL114:
 402:../../../Source/ARMCM3_STM32/flash.c ****     }
 1020              		.loc 1 402 0
 1021 0026 031C     		adds	r3, r0, #0
 1022 0028 18BF     		it	ne
 1023 002a 0123     		movne	r3, #1
 1024 002c 00E0     		b	.L105
 1025              	.L106:
 415:../../../Source/ARMCM3_STM32/flash.c **** } /*** end of FlashDone ***/
 1026              		.loc 1 415 0
 1027 002e 0123     		movs	r3, #1
 1028              	.L105:
 416:../../../Source/ARMCM3_STM32/flash.c **** 
 1029              		.loc 1 416 0
 1030 0030 1846     		mov	r0, r3
 1031 0032 08BD     		pop	{r3, pc}
 1032              	.L109:
 1033              		.align	2
 1034              	.L108:
 1035 0034 00000000 		.word	.LANCHOR2
 1036 0038 00000000 		.word	.LANCHOR1
 1037              		.cfi_endproc
 1038              	.LFE5:
 1040              		.section	.text.FlashGetUserProgBaseAddress,"ax",%progbits
 1041              		.align	2
 1042              		.global	FlashGetUserProgBaseAddress
 1043              		.thumb
 1044              		.thumb_func
 1046              	FlashGetUserProgBaseAddress:
 1047              	.LFB6:
 426:../../../Source/ARMCM3_STM32/flash.c ****   return flashLayout[0].sector_start;
 1048              		.loc 1 426 0
 1049              		.cfi_startproc
 1050              		@ args = 0, pretend = 0, frame = 0
 1051              		@ frame_needed = 0, uses_anonymous_args = 0
 1052              		@ link register save eliminated.
 428:../../../Source/ARMCM3_STM32/flash.c **** 
 1053              		.loc 1 428 0
 1054 0000 0048     		ldr	r0, .L111
 1055 0002 7047     		bx	lr
 1056              	.L112:
 1057              		.align	2
 1058              	.L111:
 1059 0004 00600008 		.word	134242304
 1060              		.cfi_endproc
 1061              	.LFE6:
 1063              		.section	.rodata.flashLayout,"a",%progbits
 1064              		.align	2
 1065              		.set	.LANCHOR0,. + 0
 1068              	flashLayout:
 1069 0000 00600008 		.word	134242304
 1070 0004 00200000 		.word	8192
 1071 0008 03       		.byte	3
 1072 0009 000000   		.space	3
 1073 000c 00800008 		.word	134250496
 1074 0010 00200000 		.word	8192
 1075 0014 04       		.byte	4
 1076 0015 000000   		.space	3
 1077 0018 00A00008 		.word	134258688
 1078 001c 00200000 		.word	8192
 1079 0020 05       		.byte	5
 1080 0021 000000   		.space	3
 1081 0024 00C00008 		.word	134266880
 1082 0028 00200000 		.word	8192
 1083 002c 06       		.byte	6
 1084 002d 000000   		.space	3
 1085 0030 00E00008 		.word	134275072
 1086 0034 00200000 		.word	8192
 1087 0038 07       		.byte	7
 1088 0039 000000   		.space	3
 1089 003c 00000108 		.word	134283264
 1090 0040 00200000 		.word	8192
 1091 0044 08       		.byte	8
 1092 0045 000000   		.space	3
 1093 0048 00200108 		.word	134291456
 1094 004c 00200000 		.word	8192
 1095 0050 09       		.byte	9
 1096 0051 000000   		.space	3
 1097 0054 00400108 		.word	134299648
 1098 0058 00200000 		.word	8192
 1099 005c 0A       		.byte	10
 1100 005d 000000   		.space	3
 1101 0060 00600108 		.word	134307840
 1102 0064 00200000 		.word	8192
 1103 0068 0B       		.byte	11
 1104 0069 000000   		.space	3
 1105 006c 00800108 		.word	134316032
 1106 0070 00200000 		.word	8192
 1107 0074 0C       		.byte	12
 1108 0075 000000   		.space	3
 1109 0078 00A00108 		.word	134324224
 1110 007c 00200000 		.word	8192
 1111 0080 0D       		.byte	13
 1112 0081 000000   		.space	3
 1113 0084 00C00108 		.word	134332416
 1114 0088 00200000 		.word	8192
 1115 008c 0E       		.byte	14
 1116 008d 000000   		.space	3
 1117 0090 00E00108 		.word	134340608
 1118 0094 00200000 		.word	8192
 1119 0098 0F       		.byte	15
 1120 0099 000000   		.space	3
 1121              		.section	.bss.bootBlockInfo,"aw",%nobits
 1122              		.align	2
 1123              		.set	.LANCHOR2,. + 0
 1126              	bootBlockInfo:
 1127 0000 00000000 		.space	516
 1127      00000000 
 1127      00000000 
 1127      00000000 
 1127      00000000 
 1128              		.section	.bss.blockInfo,"aw",%nobits
 1129              		.align	2
 1130              		.set	.LANCHOR1,. + 0
 1133              	blockInfo:
 1134 0000 00000000 		.space	516
 1134      00000000 
 1134      00000000 
 1134      00000000 
 1134      00000000 
 1135              		.text
 1136              	.Letext0:
 1137              		.file 2 "../../../Source/ARMCM3_STM32/types.h"
 1138              		.file 3 "../../../Source/cop.h"
 1139              		.file 4 "../../../Source/ARMCM3_STM32/cpu.h"
DEFINED SYMBOLS
                            *ABS*:00000000 flash.c
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:19     .text.FlashLock:00000000 $t
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:23     .text.FlashLock:00000000 FlashLock
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:40     .text.FlashLock:0000000c $d
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:45     .text.FlashGetSector:00000000 $t
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:49     .text.FlashGetSector:00000000 FlashGetSector
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:107    .text.FlashGetSector:00000038 $d
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:112    .text.FlashWriteBlock:00000000 $t
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:116    .text.FlashWriteBlock:00000000 FlashWriteBlock
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:255    .text.FlashWriteBlock:000000ac $d
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:261    .text.FlashSwitchBlock:00000000 $t
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:265    .text.FlashSwitchBlock:00000000 FlashSwitchBlock
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:350    .text.FlashSwitchBlock:0000004c $d
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:357    .text.FlashAddToBlock:00000000 $t
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:361    .text.FlashAddToBlock:00000000 FlashAddToBlock
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:479    .text.FlashInit:00000000 $t
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:484    .text.FlashInit:00000000 FlashInit
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:502    .text.FlashInit:00000010 $d
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:508    .text.FlashWrite:00000000 $t
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:513    .text.FlashWrite:00000000 FlashWrite
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:574    .text.FlashWrite:00000044 $d
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:581    .text.FlashErase:00000000 $t
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:586    .text.FlashErase:00000000 FlashErase
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:832    .text.FlashErase:0000013c $d
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:839    .text.FlashWriteChecksum:00000000 $t
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:844    .text.FlashWriteChecksum:00000000 FlashWriteChecksum
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:908    .text.FlashWriteChecksum:00000048 $d
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:914    .text.FlashVerifyChecksum:00000000 $t
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:919    .text.FlashVerifyChecksum:00000000 FlashVerifyChecksum
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:974    .text.FlashVerifyChecksum:00000038 $d
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:984    .text.FlashDone:00000000 $t
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:989    .text.FlashDone:00000000 FlashDone
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:1035   .text.FlashDone:00000034 $d
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:1041   .text.FlashGetUserProgBaseAddress:00000000 $t
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:1046   .text.FlashGetUserProgBaseAddress:00000000 FlashGetUserProgBaseAddress
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:1059   .text.FlashGetUserProgBaseAddress:00000004 $d
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:1064   .rodata.flashLayout:00000000 $d
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:1068   .rodata.flashLayout:00000000 flashLayout
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:1122   .bss.bootBlockInfo:00000000 $d
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:1126   .bss.bootBlockInfo:00000000 bootBlockInfo
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:1129   .bss.blockInfo:00000000 $d
C:\Users\lwngim1\AppData\Local\Temp\cc2UpPQC.s:1133   .bss.blockInfo:00000000 blockInfo
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
CopService
CpuMemCopy
